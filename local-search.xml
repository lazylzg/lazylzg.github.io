<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CSS 相关知识点</title>
    <link href="/2020/12/14/Front-Knowledge/2020-12-14-CSS/"/>
    <url>/2020/12/14/Front-Knowledge/2020-12-14-CSS/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？"><a href="#介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？" class="headerlink" title="介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？"></a>介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？</h2><ul><li>盒模型都是由 margin、border、padding 和 content 四个部分组成。</li><li>标准盒模型和 IE 盒模型的区别在于设置 width 和 height 所对应的范围不同。标准盒模型的 width 和 height 属性的范围只包含了 content，而 IE 盒模型的 width 和 height 属性的范围包含了 border、padding 和 content。</li></ul><h2 id="CSS-选择符有哪些？"><a href="#CSS-选择符有哪些？" class="headerlink" title="CSS 选择符有哪些？"></a>CSS 选择符有哪些？</h2><ul><li>id选择器（#myid）</li><li>类选择器（.myclassname）</li><li>标签选择器（div,h1,p）</li><li>后代选择器（h1 p）</li><li>相邻后代选择器（子）选择器（ul&gt;li）</li><li>兄弟选择器（li~a）</li><li>相邻兄弟选择器（li+a）</li><li>属性选择器（a[rel=”external”]）</li><li>伪类选择器（a:hover,li:nth-child）</li><li>伪元素选择器（::before、::after）</li><li>通配符选择器（*）</li></ul><h2 id="before-和-after-中双冒号和单冒号有什么区别？"><a href="#before-和-after-中双冒号和单冒号有什么区别？" class="headerlink" title="::before 和:after 中双冒号和单冒号有什么区别？"></a>::before 和:after 中双冒号和单冒号有什么区别？</h2><ul><li>单冒号（:）用于CSS3伪类，双冒号（::）用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）。</li><li>为了兼容已有的伪元素的写法，在一些浏览器中也可以使用单冒号来表示伪元素。</li><li>伪类一般匹配的是元素的一些特殊状态，如 hover、link 等，而伪元素一般匹配的特殊的位置，比如 after、before 等。</li></ul><h2 id="如何居中-div？"><a href="#如何居中-div？" class="headerlink" title="如何居中 div？"></a>如何居中 div？</h2><ul><li>水平居中：给 div 设置一个宽度，然后添加 margin:0 auto 属性</li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;&#125;</code></pre><ul><li>水平居中，利用 text-align:center 实现</li></ul><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>);  <span class="hljs-attribute">text-align</span>: center;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;&#125;<span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">display</span>: inline-block;  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;  <span class="hljs-attribute">background-color</span>: pink;&#125;</code></pre><ul><li>让绝对定位的 div 居中</li></ul><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;  <span class="hljs-attribute">position</span>: absolute;  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;  <span class="hljs-attribute">margin</span>: auto;  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">background-color</span>: pink; <span class="hljs-comment">/*方便看效果*/</span>&#125;</code></pre><ul><li>水平垂直居中一</li></ul><pre><code class="hljs css"><span class="hljs-comment">/*确定容器的宽高宽500高300的层设置层的外边距div&#123;*/</span><span class="hljs-selector-tag">position</span>: <span class="hljs-selector-tag">absolute</span>;<span class="hljs-comment">/*绝对定位*/</span><span class="hljs-selector-tag">width</span>: 500<span class="hljs-selector-tag">px</span>;<span class="hljs-selector-tag">height</span>: 300<span class="hljs-selector-tag">px</span>;<span class="hljs-selector-tag">top</span>: 50%;<span class="hljs-selector-tag">left</span>: 50%;<span class="hljs-selector-tag">margin</span>: <span class="hljs-selector-tag">-150px00-250px</span>;<span class="hljs-comment">/*外边距为自身宽高的一半*/</span><span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-tag">pink</span>;<span class="hljs-comment">/*方便看效果*/</span>&#125;</code></pre><ul><li>水平垂直居中二</li></ul><pre><code class="hljs css"><span class="hljs-comment">/*未知容器的宽高，利用`transform`属性*/</span><span class="hljs-selector-tag">div</span> &#123;  <span class="hljs-attribute">position</span>: absolute; <span class="hljs-comment">/*相对定位或绝对定位均可*/</span>  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);  <span class="hljs-attribute">background-color</span>: pink; <span class="hljs-comment">/*方便看效果*/</span>&#125;</code></pre><ul><li>水平垂直居中三</li></ul><pre><code class="hljs css"><span class="hljs-comment">/*利用flex布局实际使用时应考虑兼容性*/</span><span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">display</span>: flex;  <span class="hljs-attribute">align-items</span>: center; <span class="hljs-comment">/*垂直居中*/</span>  <span class="hljs-attribute">justify-content</span>: center; <span class="hljs-comment">/*水平居中*/</span>&#125;<span class="hljs-selector-class">.containerdiv</span> &#123;  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;  <span class="hljs-attribute">background-color</span>: pink; <span class="hljs-comment">/*方便看效果*/</span>&#125;</code></pre><ul><li>水平垂直居中四</li></ul><pre><code class="hljs css"><span class="hljs-comment">/*利用text-align:center和vertical-align:middle属性*/</span><span class="hljs-selector-class">.container</span> &#123;  <span class="hljs-attribute">position</span>: fixed;  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.5</span>);  <span class="hljs-attribute">text-align</span>: center;  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">0</span>;  <span class="hljs-attribute">white-space</span>: nowrap;  <span class="hljs-attribute">overflow</span>: auto;&#125;<span class="hljs-selector-class">.container</span><span class="hljs-selector-pseudo">::after</span> &#123;  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;  <span class="hljs-attribute">display</span>: inline-block;  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;  <span class="hljs-attribute">vertical-align</span>: middle;&#125;<span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">display</span>: inline-block;  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;  <span class="hljs-attribute">background-color</span>: pink;  <span class="hljs-attribute">white-space</span>: normal;  <span class="hljs-attribute">vertical-align</span>: middle;&#125;</code></pre><h2 id="display-有哪些值？"><a href="#display-有哪些值？" class="headerlink" title="display 有哪些值？"></a>display 有哪些值？</h2><table><thead><tr><th align="center">值</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">block</td><td align="center">块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</td></tr><tr><td align="center">none</td><td align="center">元素不显示，并从文档流中移除。</td></tr><tr><td align="center">inline</td><td align="center">行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</td></tr><tr><td align="center">inline-block</td><td align="center">默认宽度为内容宽度，可以设置宽高，同行显示。</td></tr><tr><td align="center">list-item</td><td align="center">像块类型元素一样显示，并添加样式列表标记。</td></tr><tr><td align="center">table</td><td align="center">此元素会作为块级表格来显示。</td></tr><tr><td align="center">inherit</td><td align="center">规定应该从父元素继承display属性的值。</td></tr></tbody></table><h2 id="position-有那些值？作用是什么？"><a href="#position-有那些值？作用是什么？" class="headerlink" title="position 有那些值？作用是什么？"></a>position 有那些值？作用是什么？</h2><ul><li><p><strong>absolute</strong><br>生成绝对定位的元素，相对于值不为 static 的第一个父元素的 padding box 进行定位，也可以理解为离自己这一级元素最近的一级 position 设置为 absolute 或者 relative 的父元素的 padding box 的左上角为原点的。</p></li><li><p><strong>fixed</strong>（老 IE 不支持）<br>生成绝对定位的元素，相对于浏览器窗口进行定位。</p></li><li><p><strong>relative</strong><br>生成相对定位的元素，相对于其元素本身所在正常位置进行定位。</p></li><li><p><strong>static</strong><br>默认值。没有定位，元素出现在正常的流中（忽略 top,bottom,left,right,z-index 声明）。</p></li><li><p><strong>inherit</strong><br>规定从父元素继承 position 属性的值。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>知识复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 中的相等操作符 ( 详解 [] == []、[] == ![]、{} == !{} )</title>
    <link href="/2020/12/12/JavaScript/2020-12-12-JavaScript%20%E4%B8%AD%E7%9A%84%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <url>/2020/12/12/JavaScript/2020-12-12-JavaScript%20%E4%B8%AD%E7%9A%84%E7%9B%B8%E7%AD%89%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>ECMAScript 中的<strong>相等操作符</strong>由两个等于号 ( <strong>==</strong> ) 表示，如果两个操作数相等，则返回 true。</p><p><strong>相等操作符会先转换操作数（通常称为强制转型）</strong>，然后比较它们的相等性。</p><p>在转换不同的数据类型时，相等操作符遵循下列基本规则：</p><ul><li><p>如果有一个操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为0，true 转换为1。</p></li><li><p>如果一个操作数是字符串，另一个操作数是数值，在比较之前先将字符串转换为数值，再比较是否相等。</p></li><li><p>如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf() 方法获得其原始值，再根据前面的规则进行比较。</p><p>在进行比较时，这两个操作符会遵循如下规则：</p><ul><li>null 和 undefined 相等。</li><li>null 和 undefined 不能转换为其他类型的值再进行比较。</li><li>如果任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。即使两个操作数都是 NaN，相等操作符也返回 false，因为按照规则 <strong>NaN 不等于 NaN</strong>。</li><li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果指向同一个对象，则相等操作符返回 true。否则，两者不相等。</li></ul></li></ul><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><p>如果相等操作符两边的操作数，不包含 null 或者 undefined，且两个操作数不全是对象，在执行相等比较之前，会先调用 Number() 将两个操作数强制转为 Number 类型，然后进行比较，所以在使用相等操作符的时候，会有以下情况：</p><pre><code class="hljs javascript"><span class="hljs-string">&#x27;55&#x27;</span> == <span class="hljs-number">55</span>;       <span class="hljs-comment">//true</span><span class="hljs-literal">false</span> == <span class="hljs-number">0</span>;       <span class="hljs-comment">//true</span><span class="hljs-string">&quot;wise&quot;</span> == <span class="hljs-number">3</span>;      <span class="hljs-comment">//false （ Number(&quot;wise&quot;) -&gt; NaN ）</span>[] == <span class="hljs-number">0</span>;          <span class="hljs-comment">//true  （ Number([]) -&gt; 0 ）</span></code></pre><p>但是在特殊情况下，也就是两边都有对象的时候，会产生看似不合理的结果：</p><pre><code class="hljs javascript"><span class="hljs-literal">NaN</span> == <span class="hljs-literal">NaN</span>;  <span class="hljs-comment">//false</span>[] == [];    <span class="hljs-comment">//false</span>[] == ![];   <span class="hljs-comment">//true</span>&#123;&#125; == &#123;&#125;;    <span class="hljs-comment">//false</span>&#123;&#125; == !&#123;&#125;;   <span class="hljs-comment">//false</span></code></pre><h2 id="和"><a href="#和" class="headerlink" title="[] == [] 和 {} == {}"></a>[] == [] 和 {} == {}</h2><p>在 JavaScript 中，<strong>Object、Array、Function、RegExp、Date</strong> <strong>都是引用类型</strong></p><p>声明引用类型的时候，变量名保存在 js 的<strong>栈内存</strong>里面，而对应的值保存在<strong>堆内存</strong>里面</p><p>而这个变量在栈内存中实际保存的是：<strong>这个值在堆内存中的地址</strong>，也就是<strong>指针</strong></p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;&#125;;<span class="hljs-keyword">var</span> b = &#123;&#125;;</code></pre><p>上面的代码中，声明变量 a 的时候，在堆内存中存储了一个 Object，声明变量 b 的时候，又存储了一个新的 Object。</p><p>虽然 a 和 b 都保存了一个 Object，但这是两个独立的 Object，它们的地址是不同的。</p><p><strong>如果两个对象指向同一个对象，相等操作符返回 true</strong></p><p>所以 <strong>{} == {}</strong> 的结果是 false，同样的， <strong>[] == []</strong> 的结果也是 false</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> c = b;b == c;   <span class="hljs-comment">//true（变量c保存的是b的指针，它们指向同一个对象）</span></code></pre><h2 id="和-1"><a href="#和-1" class="headerlink" title="[] == ![] 和 {} == !{}"></a>[] == ![] 和 {} == !{}</h2><p>ECMAScript 中规定，逻辑非 (!) 的优先级高于相等操作符 ( == )，在比较 [] == ![] 的时候，先计算 ![] 得到布尔值 false，所以实际上比较的是 <strong>[] == false</strong>，然后将两个操作数转为数值类型：</p><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>([]) == <span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>);   <span class="hljs-comment">// -&gt;  0 == 0  -&gt;  true</span></code></pre><p>在比较 {} == !{} 的时候，也是遵守同样的规则：</p><pre><code class="hljs javascript">&#123;&#125; == !&#123;&#125;  -&gt;  &#123;&#125; == <span class="hljs-literal">false</span>  -&gt;  <span class="hljs-built_in">Number</span>(&#123;&#125;) == <span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>)  -&gt;  <span class="hljs-literal">NaN</span> == <span class="hljs-number">0</span></code></pre><p><strong>如果有一个操作数是 NaN，相等操作符返回 false</strong></p><p>所以 {} == !{} 的结果是 false。</p>]]></content>
    
    
    <categories>
      
      <category>知识复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 相关知识点</title>
    <link href="/2020/12/12/Front-Knowledge/2020-12-12-JavaScript/"/>
    <url>/2020/12/12/Front-Knowledge/2020-12-12-JavaScript/</url>
    
    <content type="html"><![CDATA[<h2 id="介绍-JavaScript-的基本数据类型"><a href="#介绍-JavaScript-的基本数据类型" class="headerlink" title="介绍 JavaScript 的基本数据类型"></a>介绍 JavaScript 的基本数据类型</h2><p>六种基本数据类型（原始类型），分别是 Undefined、Null、Boolean、Number、String、Symbol（ES6 中新增），还有一种复杂的数据类型 Object（对象）。</p><h2 id="let、var、const-的区别，谈谈如何冻结变量"><a href="#let、var、const-的区别，谈谈如何冻结变量" class="headerlink" title="let、var、const 的区别，谈谈如何冻结变量"></a>let、var、const 的区别，谈谈如何冻结变量</h2><ul><li><strong>var</strong> 没有块级作用域，支持变量提升。</li><li><strong>let</strong> 有块级作用域，不支持变量提升。不允许重复声明，暂存性死区。</li><li><strong>const</strong> 有块级作用域，不支持变量提升，不允许重复声明，暂存性死区。声明一个变量一旦声明就不能改变，改变报错。const 保证的变量的<strong>内存地址</strong>不得改动。如果想要将对象冻结的话，使用Object.freeze()方法。</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> foo = <span class="hljs-built_in">Object</span>.freeze(&#123;&#125;);foo.prop = <span class="hljs-number">123</span>;<span class="hljs-built_in">console</span>.log(foo.prop);<span class="hljs-comment">//混杂模式undefined,不起作用</span></code></pre><h2 id="JavaScript-有几种类型的值？"><a href="#JavaScript-有几种类型的值？" class="headerlink" title="JavaScript 有几种类型的值？"></a>JavaScript 有几种类型的值？</h2><p>可以分为两种类型的值，一种是基本数据类型，一种是复杂数据类型。</p><p>基本数据类型指原始数据类型（Undefined、Null、Boolean、Number、String）。</p><p>复杂数据类型指引用数据类型（对象、数组和函数）。</p><p>两种类型间的主要区别是它们的存储位置不同，基本数据类型的值直接保存在栈中，而复杂数据类型的值保存在堆中，通过使用在栈中保存对应的指针来获取堆中的值。</p><h2 id="什么是堆？什么是栈？它们之间有什么区别和联系？"><a href="#什么是堆？什么是栈？它们之间有什么区别和联系？" class="headerlink" title="什么是堆？什么是栈？它们之间有什么区别和联系？"></a>什么是堆？什么是栈？它们之间有什么区别和联系？</h2><ul><li>堆和栈的概念存在于数据结构中和操作系统内存中。</li><li>在数据结构中，栈中数据的存取方式为先进后出。而堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。完全二叉树是堆的一种实现方式。</li><li>在操作系统中，内存被分为栈区和堆区。</li><li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li><li>堆区内存一般由程序员分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。</li></ul><h2 id="null-和-undefined-的区别？"><a href="#null-和-undefined-的区别？" class="headerlink" title="null 和 undefined 的区别？"></a>null 和 undefined 的区别？</h2><ul><li>Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</li><li>undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null 主要用于赋值给一些可能会返回对象的变量，作为初始化。</li><li>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，这样的做法是非常危险的，它会影响我们对 undefined 值的判断。</li><li>当我们对两种类型使用 typeof 进行判断的时候，Null 类型化会返回 “object”，这是一个历史遗留的问题。两种类型的值使用等于（==）运算符比较会返回 true，使用全等（===）运算符比较会返回 false。</li></ul><h2 id="isNaN-和-Number-isNaN-函数的区别？"><a href="#isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="isNaN 和 Number.isNaN 函数的区别？"></a>isNaN 和 Number.isNaN 函数的区别？</h2><ul><li>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</li><li>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，这种方法对于 NaN 的判断更为准确。</li></ul><h2 id="Array-构造函数只有一个参数值时的表现？"><a href="#Array-构造函数只有一个参数值时的表现？" class="headerlink" title="Array 构造函数只有一个参数值时的表现？"></a>Array 构造函数只有一个参数值时的表现？</h2><p>Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度（length），而非只充当数组中的一个元素。这样创建出来的只是一个空数组，只不过它的 length 属性被设置成了指定的值。</p><h2 id="和-的-valueOf-和-toString-的结果是什么？"><a href="#和-的-valueOf-和-toString-的结果是什么？" class="headerlink" title="{} 和 [] 的 valueOf 和 toString 的结果是什么？"></a>{} 和 [] 的 valueOf 和 toString 的结果是什么？</h2><p>{} 的 valueOf 结果为 {} ，toString 的结果为 “[object Object]”</p><p>[] 的 valueOf 结果为 [] ，toString 的结果为 “”</p><h2 id="解析字符串中的数字和将字符串强制类型转换为数字的区别是什么？"><a href="#解析字符串中的数字和将字符串强制类型转换为数字的区别是什么？" class="headerlink" title="解析字符串中的数字和将字符串强制类型转换为数字的区别是什么？"></a>解析字符串中的数字和将字符串强制类型转换为数字的区别是什么？</h2><p>解析允许字符串（如 parseInt() ）中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换（如 Number ()）不允许出现非数字字符，否则会失败并返回 NaN。</p><h2 id="Symbol-值的强制类型转换？"><a href="#Symbol-值的强制类型转换？" class="headerlink" title="Symbol 值的强制类型转换？"></a>Symbol 值的强制类型转换？</h2><ul><li><p>ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。</p></li><li><p>Symbol 值不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是 true ）。</p></li></ul><h2 id="谈谈-This-对象的理解"><a href="#谈谈-This-对象的理解" class="headerlink" title="谈谈 This 对象的理解"></a>谈谈 This 对象的理解</h2><h2 id="什么是-DOM-和-BOM？"><a href="#什么是-DOM-和-BOM？" class="headerlink" title="什么是 DOM 和 BOM？"></a>什么是 DOM 和 BOM？</h2><ul><li><p>DOM 指的是文档对象模型，它指的是把文档当做一个对象来对待，这个对象主要定义了处理网页内容的方法和接口。</p></li><li><p>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM 的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</p></li></ul><h2 id="什么是闭包，为什么要用它？"><a href="#什么是闭包，为什么要用它？" class="headerlink" title="什么是闭包，为什么要用它？"></a>什么是闭包，为什么要用它？</h2><p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p><p>闭包有两个常用的用途：</p><ul><li>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li><li>函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li></ul><h2 id="如何判断一个对象是否属于某个类？"><a href="#如何判断一个对象是否属于某个类？" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h2><ul><li><p>第一种方式是使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p></li><li><p>第二种方式可以通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</p></li><li><p>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的 [[Class]] 属性来进行判断。</p></li></ul><h2 id="同步和异步的区别？"><a href="#同步和异步的区别？" class="headerlink" title="同步和异步的区别？"></a>同步和异步的区别？</h2><ul><li><p>同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是处于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。  </p></li><li><p>异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。 </p></li></ul><h2 id="谈谈对闭包的理解，闭包的用途，闭包的缺点"><a href="#谈谈对闭包的理解，闭包的用途，闭包的缺点" class="headerlink" title="谈谈对闭包的理解，闭包的用途，闭包的缺点"></a>谈谈对闭包的理解，闭包的用途，闭包的缺点</h2><ul><li>闭包是指有权访问另外一个函数作用域中的变量的函数</li><li>闭包的用途：</li></ul><ol><li>设计私有的方法和变量。</li><li>匿名函数最大的用途是创建闭包，并且还可以构建命名空间，以减少全局变量的使用。从而使用闭包模块化代码，减少全局变量的污染。</li></ol><ul><li>闭包的缺点：</li></ul><ol><li>闭包会使得函数中的变量都被保存在内存中，滥用闭包可能导致内存泄漏。解决方法是在函数退出之前，将不使用的局部变量全删了。</li><li>闭包会在父函数外部，改变父函数内部变量的值。</li></ol><h2 id="谈谈-js-的垃圾回收机制"><a href="#谈谈-js-的垃圾回收机制" class="headerlink" title="谈谈 js 的垃圾回收机制"></a>谈谈 js 的垃圾回收机制</h2><ul><li>JavaScript拥有自动的垃圾回收机制，当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。</li><li><strong>标记清除算法：</strong></li></ul><ol><li>标记阶段，垃圾回收器会从根对象开始遍历。每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象。</li><li>清除阶段，垃圾回收器会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作。</li><li>缺点：垃圾收集后有可能会造成大量的<strong>内存碎片</strong>。</li></ol><ul><li><strong>引用计数算法：</strong></li></ul><ol><li>引用计数的含义是跟踪记录每个值被引用的次数，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</li><li>缺点： 循环引用没法回收。</li></ol><h2 id="ajax-的用途，ajax-请求的五种状态"><a href="#ajax-的用途，ajax-请求的五种状态" class="headerlink" title="ajax 的用途，ajax 请求的五种状态"></a>ajax 的用途，ajax 请求的五种状态</h2><ul><li>AJAX 是“ Asynchronous JavaScript And XML ”的缩写，是一种实现<strong>无页面刷新</strong>获取服务器数据的混合技术。</li><li><strong>XMLHttpRequest</strong> 对象是浏览器提供的一个 API，用来顺畅地向服务器发送请求并解析服务器响应，当然整个过程中，浏览器页面不会被刷新。</li><li>.open() 方法接收三个参数：请求方式（get or post），请求 URL 地址和是否为异步请求的布尔值。“同步”意味着一旦请求发出，任何后续的 JavaScript 代码不会再执行，“异步”则是当请求发出后，后续的 JavaScript 代码会继续执行，当请求成功后，会调用相应的回调函数。</li></ul><pre><code class="hljs javascript"><span class="hljs-comment">// 该段代码会启动一个针对“example.php”的GET同步请求。</span>xhr.open(<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;example.php&quot;</span>, <span class="hljs-literal">false</span>)</code></pre><ul><li>xhr 实例的 readystatechange 事件会监听 xhr.readyState 属性的变化，有以下五种变化：</li></ul><table><thead><tr><th>readyState</th><th>对应常量</th><th>描述</th></tr></thead><tbody><tr><td>0(未初始化)</td><td>xhr.UNSENT</td><td>请求已建立, 但未初始化(此时未调用open方法)</td></tr><tr><td>1(初始化)</td><td>xhr.OPENED</td><td>请求已建立, 但未发送 (已调用open方法, 但未调用send方法)</td></tr><tr><td>2(发送数据)</td><td>xhr.HEADERS_RECEIVED</td><td>请求已发送 (send方法已调用, 已收到响应头)</td></tr><tr><td>3(数据发送中)</td><td>xhr.LOADING</td><td>请求处理中, 因响应内容不全, 这时通过responseBody和responseText获取可能会出现错误</td></tr><tr><td>4(完成)</td><td>xhr.DONE</td><td>数据接收完毕, 此时可以通过responseBody和responseText获取完整的响应数据</td></tr></tbody></table><h2 id="call、apply、bind-的区别"><a href="#call、apply、bind-的区别" class="headerlink" title="call、apply、bind 的区别"></a>call、apply、bind 的区别</h2><ul><li><strong>call、apply 与 bind 的差别：</strong></li></ul><ol><li>call 和 apply 改变了函数的 this 上下文后便执行该函数，而 bind 则是返回改变了上下文后的一个函数。</li></ol><ul><li><strong>call、apply 的区别：</strong></li></ul><ol><li>call 和 aplly 的第一个参数都是要改变上下文的对象，而 call 从第二个参数开始以参数列表的形式展现，apply 则是把除了改变上下文对象的参数放在一个数组里面作为它的第二个参数。</li></ol><pre><code class="hljs javascript">fn.call(obj, arg1, arg2, arg3...);fn.apply(obj, [arg1, arg2, arg3...]);</code></pre><h2 id="setTimeout-和-setInterval-的区别，包含内存方面的分析？"><a href="#setTimeout-和-setInterval-的区别，包含内存方面的分析？" class="headerlink" title="setTimeout 和 setInterval 的区别，包含内存方面的分析？"></a>setTimeout 和 setInterval 的区别，包含内存方面的分析？</h2><ul><li>setTimeout 表示间隔一段时间之后执行一次调用，而 setInterval 则是每间隔一段时间循环调用，直至 clearInterval 结束。</li><li>内存方面，setTimeout 只需要进入一次队列，不会造成内存溢出，setInterval 因为不计算代码执行时间，有可能同时执行多次代码，导致内存溢出。</li></ul><h2 id="如何用-setTimeout-实现-setInterval？"><a href="#如何用-setTimeout-实现-setInterval？" class="headerlink" title="如何用 setTimeout 实现 setInterval？"></a>如何用 setTimeout 实现 setInterval？</h2><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> _setInterval = <span class="hljs-function">(<span class="hljs-params">fn, misc</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> interval = <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-built_in">setTimeout</span>(interval, misc);        fn();    &#125;    <span class="hljs-built_in">setTimeout</span>(interval, misc);&#125;</code></pre><h2 id="什么是深拷贝，什么是浅拷贝？"><a href="#什么是深拷贝，什么是浅拷贝？" class="headerlink" title="什么是深拷贝，什么是浅拷贝？"></a>什么是深拷贝，什么是浅拷贝？</h2><ul><li><p>浅拷贝是指仅仅复制对象的引用，而不是复制对象本身。</p></li><li><p>深拷贝则是把复制对象所引用的全部对象都复制一遍。</p></li></ul><h2 id="JavaScript-中-forEach-和-map-方法的区别"><a href="#JavaScript-中-forEach-和-map-方法的区别" class="headerlink" title="JavaScript 中 forEach 和 map 方法的区别"></a>JavaScript 中 forEach 和 map 方法的区别</h2><ul><li>forEach 返回值是 undefined，不可链式调用。</li><li>map 返回一个新数组，原数组不会改变。</li><li>没有办法终止或者跳出 forEach 循环，除非抛出异常，如果想执行一个数组是否满足什么条件，可以用 Array.every() 或者 Array.some()。</li></ul><h2 id="script-标签如何异步加载？"><a href="#script-标签如何异步加载？" class="headerlink" title="script 标签如何异步加载？"></a>script 标签如何异步加载？</h2><p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到 script 标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。</p><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">&quot;js1.js&quot;</span> defer&gt;&lt;/script&gt;&lt;script src=<span class="hljs-string">&quot;js2.js&quot;</span> <span class="hljs-keyword">async</span>&gt;&lt;/script&gt;</code></pre><ul><li><strong>defer与async的区别是：</strong></li></ul><ol><li>加载时间：defer 要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；async 一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，defer 是“渲染完再执行”，async 是“下载完就执行”。</li><li>执行顺序：如果有多个 defer 脚本，会按照它们在页面出现的顺序加载，而多个 async 脚本是不能保证加载顺序的。</li></ol><h2 id="箭头函数和普通函数的区别是什么？"><a href="#箭头函数和普通函数的区别是什么？" class="headerlink" title="箭头函数和普通函数的区别是什么？"></a>箭头函数和普通函数的区别是什么？</h2><ul><li>普通函数 this：</li></ul><ol><li>this 总是代表它的直接调用者。</li><li>在默认情况下，没找到直接调用者，this 指的是 window。</li><li>在严格模式下，没有直接调用者的函数中的 this 是 undefined。</li><li>使用 call，apply，bind 绑定，this 指的是绑定的对象。</li></ol><ul><li>箭头函数 this：</li></ul><ol><li>在使用=&gt;定义函数的时候，this的指向是 <strong>定义时所在的对象</strong>，而不是使用时所在的对象。</li><li><strong>不能够用作构造函数</strong>，这就是说，不能够使用 new 命令，否则就会抛出一个错误。</li><li>不能够使用 <strong>arguments</strong> 对象。</li><li>不能使用 <strong>yield</strong> 命令。</li></ol><h2 id="举出三种判断数组的方法？"><a href="#举出三种判断数组的方法？" class="headerlink" title="举出三种判断数组的方法？"></a>举出三种判断数组的方法？</h2><ul><li><strong>Object.prototype.toString.call()</strong></li><li><strong>instanceof</strong></li><li><strong>Array.isArray()</strong></li></ul><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.prototype.toString.call(an); <span class="hljs-comment">// &quot;[object Array]&quot;</span>[] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>; <span class="hljs-comment">// true</span><span class="hljs-built_in">Array</span>.isArray(arr);  <span class="hljs-comment">// true</span></code></pre><h2 id="使用-sort-对数组-3-15-8-29-102-22-进行排序，输出结果？"><a href="#使用-sort-对数组-3-15-8-29-102-22-进行排序，输出结果？" class="headerlink" title="使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果？"></a>使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果？</h2><ul><li>sort 函数，可以接收一个函数，返回值是比较两个数的相对顺序的值。</li><li>根据 MDN 上对 Array.sort() 的解释，默认的排序方法会将数组元素转换为字符串，然后比较字符串中字符的 UTF-16 编码顺序来进行排序。所以’102’ 会排在 ‘15’ 前面。结果是[102, 15, 22, 29, 3, 8]。</li></ul>]]></content>
    
    
    <categories>
      
      <category>知识复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML相关知识点</title>
    <link href="/2020/12/04/Front-Knowledge/2020-12-4-HTML/"/>
    <url>/2020/12/04/Front-Knowledge/2020-12-4-HTML/</url>
    
    <content type="html"><![CDATA[<h2 id="DOCTYPE-的作用是什么？"><a href="#DOCTYPE-的作用是什么？" class="headerlink" title="DOCTYPE 的作用是什么？"></a>DOCTYPE 的作用是什么？</h2><ul><li>IE5.5 引入了文档模式的概念，而这个概念是通过使用文档类型（DOCTYPE）切换实现的。</li><li>&lt;!DOCTYPE&gt;声明位于 HTML 文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。</li><li>DOCTYPE 不存在或格式不正确会导致文档以兼容模式呈现。</li></ul><h2 id="标准模式与兼容模式各有什么区别？"><a href="#标准模式与兼容模式各有什么区别？" class="headerlink" title="标准模式与兼容模式各有什么区别？"></a>标准模式与兼容模式各有什么区别？</h2><p>标准模式的渲染方式和 JS 引擎的解析方式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</p><h2 id="HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-，而不需要引入-DTD？"><a href="#HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt-，而不需要引入-DTD？" class="headerlink" title="HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;，而不需要引入 DTD？"></a>HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;，而不需要引入 DTD？</h2><p>HTML5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 DOCTYPE 来规范浏览器的行为（让浏览器按照它们应该的方式来运行）。而 HTML4.01 基于 SGML ，所以需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型。</p><h2 id="SGML-、-HTML-、XML-和-XHTML-的区别？"><a href="#SGML-、-HTML-、XML-和-XHTML-的区别？" class="headerlink" title="SGML 、 HTML 、XML 和 XHTML 的区别？"></a>SGML 、 HTML 、XML 和 XHTML 的区别？</h2><ul><li>SGML 是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。</li><li>HTML 是超文本标记语言，主要是用于规定怎么显示网页。</li><li>XML 是可扩展标记语言是未来网页语言的发展方向，XML 和 HTML 的最大区别就在于 XML 的标签是可以自己创建的，数量无限多，而 HTML 的标签都是固定的而且数量有限。</li><li>XHTML 也是现在基本上所有网页都在用的标记语言，他其实和 HTML 没什么本质的区别，标签都一样，用法也都一样，就是比 HTML 更严格，比如标签必须都用小写，标签都必须有闭合标签等。</li></ul><h2 id="DTD-介绍"><a href="#DTD-介绍" class="headerlink" title="DTD 介绍"></a>DTD 介绍</h2><ul><li>DTD（ Document Type Definition 文档类型定义）是一组机器可读的规则，它们定义 XML 或 HTML 的特定版本中所有允许元素及它们的属性和层次关系的定义。在解析网页时，浏览器将使用这些规则检查页面的有效性并且采取相应的措施。</li><li>DTD 是对 HTML 文档的声明，还会影响浏览器的渲染模式（工作模式）。</li></ul><h2 id="viewport-的常见设置有哪些"><a href="#viewport-的常见设置有哪些" class="headerlink" title="viewport 的常见设置有哪些"></a>viewport 的常见设置有哪些</h2><p>viewport 常常使用在响应式开发以及移动 web 开发中，viewport 顾名思义就是用来设置视口，主要是规定视口的宽度、视口的初始缩放值、视口的最小缩放值、视口的最大缩放值、是否允许用户缩放等。常见的 viewport 设置如下：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span>  <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;initial-scale=1,maximum-scale=1,user-scalable=no,width=device-width&quot;</span> /&gt;</span></code></pre><p>其中同时设置 width 和 initial-scale 的目的是为了解决 iphone、ipad、ie 横竖屏不分的情况，因为这两个值同时存在时会取较大值。</p><h2 id="简要介绍-HTML5-的新特性"><a href="#简要介绍-HTML5-的新特性" class="headerlink" title="简要介绍 HTML5 的新特性"></a>简要介绍 HTML5 的新特性</h2><ul><li>首先 HTML5 为了更好的实践 Web 语义化，增加了 header、footer、nav、aside、article、section 等语义化标签；</li><li>在表单方面，为了增强表单，为 input 增加 color、email、date、range、url 等类型；</li><li>在存储方面提供了 sessionStorage、localStorage 和离线存储，通过这些存储方式方便数据在客户端的存储和获取；</li><li>在多媒体方面规定了音频和视频元素 audio 和 video；</li><li>另外还有地理定位、canvas 画布、拖放、多线程编程的 web workers 和 websocket 协议。</li></ul><h2 id="HTML5-的存储方案有哪些"><a href="#HTML5-的存储方案有哪些" class="headerlink" title="HTML5 的存储方案有哪些"></a>HTML5 的存储方案有哪些</h2><ul><li>HTML5 提供了 sessionStorage、localStorage 和离线存储作为新的存储方案。</li><li>sessionStorage 和 localStorage 都是采用键值对的形式存储，两者都是通过 setItem、getItem、removeItem 来实现增删查改，而sessionStorage 是会话存储，也就是说当浏览器关闭之后 sessionStorage 也自动清空了，而 localStorage 不会，它没有时间上的限制。</li><li>离线存储也就是应用程序缓存，这个通常用来确保web应用能够在离线情况下使用，通过在html标签中属性manifest来声明需要缓存的文件，这个属性的值是一个包含需要缓存的文件的文件名的文件，这个manifest文件声明的缓存文件可在初次加载后缓存在客户端，可以通过更新这个manifest文件来达到更新缓存文件的目的。</li></ul><h2 id="块级元素和行内元素有哪些？"><a href="#块级元素和行内元素有哪些？" class="headerlink" title="块级元素和行内元素有哪些？"></a>块级元素和行内元素有哪些？</h2><ul><li>块级元素（block）：有表示布局类的 div、section、header、footer、aside、nav、article等，列表类 ul li、ol 之类的，form、p、table、td、tr，标题 h1~h6。</li><li>行内元素（inline）：a、span、button、input、select、textarea、i、em、strong。</li></ul><h2 id="行内元素与块级元素的区别？"><a href="#行内元素与块级元素的区别？" class="headerlink" title="行内元素与块级元素的区别？"></a>行内元素与块级元素的区别？</h2><blockquote><p>HTML4中，元素被分成两大类：inline （内联元素）与 block （块级元素）。</p></blockquote><ul><li>格式上，默认情况下，行内元素不会以新行开始，而块级元素会新起一行。</li><li>内容上，默认情况下，行内元素只能包含文本和其他行内元素。而块级元素可以包含行内元素和其他块级元素。</li><li>行内元素与块级元素属性的不同，主要是盒模型属性上：行内元素设置 width 无效，height 无效（可以设置 line-height），设置 margin 和 padding 的上下不会对其他元素产生影响。</li></ul><h2 id="HTML5-元素的分类"><a href="#HTML5-元素的分类" class="headerlink" title="HTML5 元素的分类"></a>HTML5 元素的分类</h2><p>HTML5中，元素主要分为7类：Metadata Flow Sectioning Heading Phrasing Embedded Interactive</p><h2 id="什么是-web-语义化，有什么好处？"><a href="#什么是-web-语义化，有什么好处？" class="headerlink" title="什么是 web 语义化，有什么好处？"></a>什么是 web 语义化，有什么好处？</h2><ul><li>web 语义化：让机器可以读懂内容。有以下好处：</li></ul><ol><li>开发者友好：使用语义类标签增强了可读性，开发者也能够清晰地看出网页的结构，也更为便于团队的开发和维护。</li><li>搜索引擎友好： 有利于 SEO，有利于搜索引擎 <strong>爬虫</strong> 更好的理解我们的网页，从而获取更多的有效信息，提升网页的权重。</li><li>机器友好：语义类还可以支持读屏软件，根据文章可以自动生成目录。方便特殊群体阅读信息，比如屏幕阅读器/盲人阅读器对 <strong>strong</strong> 会有一个加重的读音。</li></ol><h2 id="meta-标签的定义和作用？"><a href="#meta-标签的定义和作用？" class="headerlink" title="meta 标签的定义和作用？"></a>meta 标签的定义和作用？</h2><ul><li>meta 标签是 head 部的一个辅助性标签，提供关于 HTML 文档的元数据。它并不会显示在页面上，但对于机器是可读的。可用于浏览器（如何显示内容或重新加载页面），搜索引擎（SEO），或其他 web 服务。</li><li>meta 标签里的数据是供机器解读的，其主要作用有：搜索引擎优化（SEO），定义页面使用语言，自动刷新并指向新的页面，实现网页转换时的动态效果，控制页面缓冲，网页定级评价，控制网页显示的窗口等等。</li><li><strong>http-equiv 属性</strong></li></ul><ol><li><strong>charset</strong> 用以说明网页制作所使用的文字以及语言</li><li><strong>cache-control、Pragma、Expires</strong> 设置网页的过期时间，一旦过期则必须到服务器上重新获取。</li><li><strong>refresh</strong> 定时让网页在指定的时间n内，跳转到页面</li><li><strong>set-cookie</strong> Cookie 设定，如果网页过期，存盘的 cookie 将被删除。 </li></ol><ul><li><strong>name 属性</strong></li></ul><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 设定字符集 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=utf-8&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 页面关键词 keywords --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;your keywords&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 页面描述内容 description --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;your description&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 定义网页作者 author --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;author,email address&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 定义网页搜索引擎索引方式，robotterms 是一组使用英文逗号「,」分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robots&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;index,follow&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 优先使用最新的chrome版本 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;chrome=1&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!-- 禁止自动翻译 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;google&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;notranslate&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 禁止转码 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Cache-Control&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;no-transform&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 选择使用的浏览器解析内核 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;renderer&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;webkit|ie-comp|ie-stand&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 移动端 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1, user-scalable=no&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;apple-mobile-web-app-capable&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;yes&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;apple-mobile-web-app-status-bar-style&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;black&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;format-detection&quot;</span><span class="hljs-attr">content</span>=<span class="hljs-string">&quot;telephone=no, email=no&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1, user-scalable=no&quot;</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;apple-mobile-web-app-capable&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;yes&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!-- 删除苹果默认的工具栏和菜单栏 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;apple-mobile-web-app-status-bar-style&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;black&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!-- 设置苹果工具栏颜色 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;format-detection&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;telphone=no, email=no&quot;</span> /&gt;</span><span class="hljs-comment">&lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;</span><span class="hljs-comment">&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;renderer&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;webkit&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 避免IE使用兼容模式 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;HandheldFriendly&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- 微软的老式浏览器 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MobileOptimized&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;320&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- uc强制竖屏 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;screen-orientation&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;portrait&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- QQ强制竖屏 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;x5-orientation&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;portrait&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- UC强制全屏 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;full-screen&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;yes&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- QQ强制全屏 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;x5-fullscreen&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- UC应用模式 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;browsermode&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;application&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- QQ应用模式 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;x5-page-mode&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-comment">&lt;!-- windows phone 点击无高光 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;msapplication-tap-highlight&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;no&quot;</span>&gt;</span></code></pre><h2 id="页面导入样式时，使用-link-和-import-有什么区别？"><a href="#页面导入样式时，使用-link-和-import-有什么区别？" class="headerlink" title="页面导入样式时，使用 link 和 @import 有什么区别？"></a>页面导入样式时，使用 link 和 @import 有什么区别？</h2><ul><li>从属关系：@import 是 CSS 提供的语法规则，只有导入样式表的作用；link 是 HTML 提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性、引入网站图标等。</li><li>加载顺序：加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载。</li><li>兼容性：@import 是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link 标签作为 HTML 元素，不存在兼容性问题。</li><li>DOM 可控性：可以通过 JS 操作 DOM ，插入 link 标签来改变样式；由于 DOM 方法是基于文档的，无法使用 @import 的方式插入样式。</li></ul><h2 id="浏览器的渲染原理-过程？"><a href="#浏览器的渲染原理-过程？" class="headerlink" title="浏览器的渲染原理/过程？"></a>浏览器的渲染原理/过程？</h2><ol><li>首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</li><li>然后对 CSS 进行解析，生成 CSSOM 规则树。</li><li>根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM 元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li><li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</li><li>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li></ol><p>值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p><h2 id="渲染过程中遇到-JS-文件怎么处理？（浏览器解析过程）"><a href="#渲染过程中遇到-JS-文件怎么处理？（浏览器解析过程）" class="headerlink" title="渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）"></a>渲染过程中遇到 JS 文件怎么处理？（浏览器解析过程）</h2><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么 它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解 析文档。</p><p>也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的 原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</p><h2 id="async-和-defer-的作用是什么？有什么区别？（浏览器解析过程）"><a href="#async-和-defer-的作用是什么？有什么区别？（浏览器解析过程）" class="headerlink" title="async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）"></a>async 和 defer 的作用是什么？有什么区别？（浏览器解析过程）</h2><ul><li>脚本没有 defer 或 async，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。</li><li>defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。<br>当整个 document 解析完毕后再执行脚本文件，在 DOMContentLoaded 事件触发之前完成。多个脚本按顺序执行。</li><li>async 属性表示异步执行引入的 JavaScript，与 defer 的区别在于，如果已经加载好，就会开始执行，也就是说它的执行仍然会阻塞文档的解析，只是它的加载过程不会阻塞。多个脚本的执行顺序无法保证。</li></ul><h2 id="简述一下你对-HTML-语义化的理解？"><a href="#简述一下你对-HTML-语义化的理解？" class="headerlink" title="简述一下你对 HTML 语义化的理解？"></a>简述一下你对 HTML 语义化的理解？</h2><ul><li>用正确的标签做正确的事情。</li><li>html 语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析。</li><li>即使在没有样式 CSS 情况下也以一种文档格式显示，并且是容易阅读的。</li><li>搜索引擎的爬虫也依赖于 HTML 标记来确定上下文和各个关键字的权重，利于 SEO。</li><li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。</li></ul><h2 id="b-与-strong-的区别和-i-与-em-的区别？"><a href="#b-与-strong-的区别和-i-与-em-的区别？" class="headerlink" title="b 与 strong 的区别和 i 与 em 的区别？"></a>b 与 strong 的区别和 i 与 em 的区别？</h2><ul><li>从页面显示效果来看，被 &lt;b&gt; 和 &lt;strong&gt; 包围的文字将会被加粗，而被 &lt;i&gt; 和 &lt;em&gt; 包围的文字将以斜体的形式呈现。 </li><li>&lt;b&gt; &lt;i&gt; 是自然样式标签，分别表示无意义的加粗，无意义的斜体，表现样式为 { font-weight: bolde r}，仅仅表示这里应该用粗体显示或者这里应该用斜体显示，此两个标签在 HTML4.01 中并不被推荐使用。</li><li>&lt;em&gt; 和 &lt;strong&gt; 是语义样式标签。 &lt;em&gt; 表示一般的强调文本，而 &lt;strong&gt; 表示比 &lt;em&gt; 语义更强的强调文本。 使用阅读设备阅读网页时：&lt;strong&gt; 会重读，而 &lt;b&gt; 是展示强调内容。</li></ul><h2 id="title-与-h1-的区别？"><a href="#title-与-h1-的区别？" class="headerlink" title="title 与 h1 的区别？"></a>title 与 h1 的区别？</h2><p>title 属性没有明确意义只表示是个标题，h1 则表示层次明确的标题，对页面信息的抓取也有很大的影响。</p><h2 id="常见的浏览器端的存储技术有哪些？"><a href="#常见的浏览器端的存储技术有哪些？" class="headerlink" title="常见的浏览器端的存储技术有哪些？"></a>常见的浏览器端的存储技术有哪些？</h2><ul><li>浏览器常见的存储技术有 cookie、localStorage 和 sessionStorage。</li><li>还有两种存储技术用于大规模数据存储，webSQL（已被废除）和 indexDB。</li><li>IE 支持 userData 存储数据，但是基本很少使用到，除非有很强的浏览器兼容需求。</li></ul><h2 id="attribute-和-property-的区别是什么？"><a href="#attribute-和-property-的区别是什么？" class="headerlink" title="attribute 和 property 的区别是什么？"></a>attribute 和 property 的区别是什么？</h2><ul><li>attribute 是 dom 元素在文档中作为 html 标签拥有的属性。</li><li>property 就是 dom 元素在 js 中作为对象拥有的属性。</li><li>对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的，但是对于自定义的属性来说，他们是不同步的。</li></ul><h2 id="head-标签中必不少的是？"><a href="#head-标签中必不少的是？" class="headerlink" title="head 标签中必不少的是？"></a>head 标签中必不少的是？</h2><ul><li>&lt;head&gt; 标签用于定义文档的头部，它是所有头部元素的容器。&lt;head&gt; 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。</li><li>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数 据都不会真正作为内容显示给读者。</li><li>下面这些标签可用在 head 部分：&lt;base&gt;, &lt;link&gt;, &lt;meta&gt;, &lt;script&gt;, &lt;style&gt;, 以及 &lt;title&gt;。</li><li>&lt;title&gt; 定义文档的标题，它是 head 部分中唯一必需的元素。</li></ul>]]></content>
    
    
    <categories>
      
      <category>知识复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>HTML5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络相关知识点</title>
    <link href="/2020/11/30/Front-Knowledge/2020-11-30-Network/"/>
    <url>/2020/11/30/Front-Knowledge/2020-11-30-Network/</url>
    
    <content type="html"><![CDATA[<h2 id="从-URL-输入到页面展现发生了什么"><a href="#从-URL-输入到页面展现发生了什么" class="headerlink" title="从 URL 输入到页面展现发生了什么?"></a>从 URL 输入到页面展现发生了什么?</h2><ol><li>在浏览器中输入 URL。</li><li>应用层 DNS 解析域名：先本地查找，再查询 DNS 服务器。</li><li>应用层客户端发送 HTTP 请求。</li><li>传输层 TCP 传输报文：三次握手。</li><li>网络层 IP 协议查询 MAC 地址。</li><li>数据到达数据链路层。</li><li>服务器接收数据。</li><li>服务器响应请求。</li><li>服务器返回相应文件。</li><li>页面渲染。解析HTML以构建DOM树 –&gt; 构建渲染树 –&gt; 布局渲染树 –&gt; 绘制渲染树。</li></ol><h2 id="OSI-的体系结构"><a href="#OSI-的体系结构" class="headerlink" title="OSI 的体系结构"></a>OSI 的体系结构</h2><ul><li>应用层：文件传输，常用协议，snmp ，FTP。</li><li>表示层：数据格式化，代码转换，数据加密。</li><li>会话层：建立、解除会话。</li><li>传输层：负责端到端的可靠性传输，TCP 与 UDP。</li><li>网络层：为数据包选择路由。</li><li>数据链路层：传输有地址的帧。</li><li>物理层：二进制的数据形式在物理媒体上传输数据。</li></ul><h2 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h2><ul><li><p>应用层：提供用户接口，特指能够发起网络流量的程序，比如客户端程序：QQ、浏览器等；服务器程序：web 服务器，邮件服务器。数据单位为报文。</p></li><li><p>运输层：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：TCP 和 UDP。</p></li><li><p>网络层：为主机间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。（负责选择最佳路径规划 IP 地址）</p><ul><li>路由器查看数据包目标 IP 地址，根据路由表为数据包选择路径。路由表中的类目可以人工添加（静态路由）也可以动态生成（动态路由）</li></ul></li><li><p>数据链路层：不同的网络类型，发送数据的机制不同，数据链路层就是将数据包封装成能够在不同的网络传输的帧。能够进行差错检验，但不纠错，监测处错误丢掉该帧。</p><ul><li>帧的开始和结束，透明传输，差错校验</li></ul></li><li><p>物理层：物理层解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的主要任务描述为：确定与传输媒体的接口的一些特性，机械、电气、功能和过程特性。</p></li></ul><h2 id="cookie、sessionStorage、localStorage-区别"><a href="#cookie、sessionStorage、localStorage-区别" class="headerlink" title="cookie、sessionStorage、localStorage 区别"></a>cookie、sessionStorage、localStorage 区别</h2><ul><li>生命周期数据有效期不同：<ul><li>Cookie：可设置失效时间，否则默认为关闭浏览器后失效。</li><li>Localstorage：除非被手动清除，否则永久保存。</li><li>Sessionstorage：仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。</li></ul></li><li>存放数据大小：<ul><li>Cookie：4k左右。</li><li>Localstorage 和 sessionstorage：可以保存5M的信息。</li></ul></li><li>http请求：<ul><li>Cookie：每次都会携带在http头中，如果使用 cookie 保存过多数据会带来性能问题。</li><li>Localstorage 和 sessionstorage：仅在客户端即浏览器中保存，不参与和服务器的通信。</li></ul></li><li>易用性：<ul><li>Cookie：需要自己封装，原生的 cookie 接口不友好。</li><li>Localstorage 和 sessionstorage：既可采用原生接口，亦可再次封装。</li></ul></li><li>作用域不同：<ul><li>sessionStorage：不在不同的浏览器窗口中共享，即使是同一个页面。</li><li>localStorage：在所有同源窗口都是共享的。</li><li>cookie：也是在所有同源窗口中共享的。</li></ul></li></ul><h2 id="cookie-和-session-的异同"><a href="#cookie-和-session-的异同" class="headerlink" title="cookie 和 session 的异同"></a>cookie 和 session 的异同</h2><ul><li>cookie 数据存放在客户的浏览器上，session 数据放在服务器上。</li><li>cookie 不是很安全，别人可以分析存放在本地的 cookie 并进行 cookie 欺骗，考虑到安全应当使用 session。</li><li>session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用 cookie。</li><li>单个 cookie 保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个 cookie。</li><li>可以考虑将登陆信息等重要信息存放为 session，其他信息如果需要保留，可以放在 cookie中。</li></ul><h2 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h2><ul><li>GET 在浏览器回退时是无害的，而 POST 会再次提交请求。</li><li>GET 产生的 URL 地址可以被加入书签，而 POST 不可以。</li><li>GET 请求会被浏览器主动缓存，请求参数会被完整保留在浏览器历史记录，而 POST 不会。</li><li>GET 请求传送的参数是有长度限制的，而 POST 使用 request body 传输数据，没有限制。</li><li>对于参数的数据类型，GET 只接受 ASCII 字符，而 POST 支持更多的编码类型且不对数据类型限制。</li><li>GET 比 POST 不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。</li><li>GET 多用于无副作用，幂等的场景，例如搜索关键字；POST 多用于副作用，不幂等的场景，例如注册。</li><li>备注：副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。幂等指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。因为前者是多了一个账号（资源），后者只是更新同一个资源。</li></ul><h2 id="Accept-和-Content-Type"><a href="#Accept-和-Content-Type" class="headerlink" title="Accept 和 Content-Type"></a>Accept 和 Content-Type</h2><p>Accept 请求头用来告知客户端可以处理的内容类型，这种内容类型用MIME类型来表示。 服务器使用 Content-Type 应答头通知客户端它的选择。</p><pre><code class="hljs http"><span class="hljs-attribute">Accept</span>: text/html<span class="hljs-attribute">Accept</span>: image/*<span class="hljs-attribute">Accept</span>: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8</code></pre><ul><li><p>Accept 属于请求头， Content-Type 属于实体头。<br>Http 报头分为通用报头，请求报头，响应报头和实体报头<br>请求方的 http 报头结构：通用报头|请求报头|实体报头<br>响应方的 http 报头结构：通用报头|响应报头|实体报头</p></li><li><p>Accept 代表发送端（客户端）希望接受的数据类型。<br>比如：Accept：text/xml;<br>代表客户端希望接受的数据类型是xml类型</p></li></ul><p>Content-Type 代表发送端（客户端|服务器）发送的实体数据的数据类型。<br>比如：Content-Type：text/html；<br>代表发送端发送的数据格式是 html。</p><p>二者合起来，<br>Accept：text/xml<br>Content-Type：text/html<br>即代表希望接受的数据类型是 xml 格式，本次请求发送的数据的数据格式是 html。</p><h2 id="HTTP-返回的状态码分类"><a href="#HTTP-返回的状态码分类" class="headerlink" title="HTTP 返回的状态码分类"></a>HTTP 返回的状态码分类</h2><table><thead><tr><th>状态码</th><th>类别</th><th>描述</th></tr></thead><tbody><tr><td>1xx</td><td>Informational（信息状态码）</td><td>接受请求正在处理</td></tr><tr><td>2xx</td><td>Success（成功状态码）</td><td>请求正常处理完毕</td></tr><tr><td>3xx</td><td>Redirection（重定向状态码）</td><td>需要附加操作已完成请求</td></tr><tr><td>4xx</td><td>Client Error（客户端错误状态码）</td><td>服务器无法处理请求</td></tr><tr><td>5xx</td><td>Server Error（服务器错误状态码）</td><td>服务器处理请求出错</td></tr></tbody></table><h2 id="HTTP-返回的状态码"><a href="#HTTP-返回的状态码" class="headerlink" title="HTTP 返回的状态码"></a>HTTP 返回的状态码</h2><p>200  OK  请求成功。一般用于GET与POST请求</p><p>201  Created  已创建。成功请求并创建了新的资源</p><p>202  Accepted  已接受。已经接受请求，但未处理完成</p><p>203  Non-Authoritative Information  非授权信息。请求成功。但返回的 meta 信息不在原始的服务器，而是一个副本</p><p>204  No Content  无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</p><p>205  Reset Content  重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。</p><p>206  Partial Content  部分内容。服务器成功处理了部分GET请求</p><p>300  Multiple Choices  多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</p><p>301  Moved Permanently  永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的URI代替</p><p>302  Found  临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有 URL</p><p>303  See Other  查看其它地址。与301类似。使用 GET 和 POST 请求查看</p><p>304  Not Modified  未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</p><p>305  Use Proxy  使用代理。所请求的资源必须通过代理访问</p><p>306  Unused  已经被废弃的 HTTP 状态码</p><p>307  Temporary Redirect  临时重定向。与302类似。使用 POST 请求重定向</p><p>400  Bad Request  客户端请求的语法错误，服务器无法理解</p><p>401  Unauthorized  请求要求用户的身份认证</p><p>402  Payment Required  保留，将来使用</p><p>403  Forbidden  服务器理解请求客户端的请求，但是拒绝执行此请求</p><p>404  Not Found  服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</p><p>500  Internal Server Error  服务器内部错误，无法完成请求</p><p>501  Not Implemented  服务器不支持请求的功能，无法完成请求</p><p>502  Bad Gateway  作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</p><p>503  Service Unavailable  由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</p><p>504  Gateway Time-out  充当网关或代理的服务器，未及时从远端服务器获取请求</p><p>505  HTTP Version not supported  服务器不支持请求的 HTTP 协议的版本，无法完成处理</p><h2 id="如何处理不让别人盗用你的图片，访问你的服务器资源"><a href="#如何处理不让别人盗用你的图片，访问你的服务器资源" class="headerlink" title="如何处理不让别人盗用你的图片，访问你的服务器资源"></a>如何处理不让别人盗用你的图片，访问你的服务器资源</h2><ul><li>http header，对 refer 做判断看来源是不是自己的网站，如果不是就拒绝。</li><li>通过 session 校验，如果不通过特定服务生成 cookie 和 session 就不能请求得到资源。</li></ul><h2 id="HTTP-与-HTTPS-的区别"><a href="#HTTP-与-HTTPS-的区别" class="headerlink" title="HTTP 与 HTTPS 的区别"></a>HTTP 与 HTTPS 的区别</h2><blockquote><p>HTTPS：建立一个信息安全通道，来确保数组的传输，确保网站的真实性</p></blockquote><ul><li>HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头。</li><li>HTTP 是不安全的，而 HTTPS 是安全的。</li><li>HTTP 标准端口是80 ，而 HTTPS 的标准端口是443。</li><li>在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 的安全传输机制工作在传输层。</li><li>HTTP 无法加密，而 HTTPS 对传输的数据进行加密。</li><li>HTTP 无需证书，而 HTTPS 需要 CA 机构的颁发的SSL证书，费用较高。</li></ul><h2 id="HTTPS-的优点"><a href="#HTTPS-的优点" class="headerlink" title="HTTPS 的优点"></a>HTTPS 的优点</h2><ul><li>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器。</li><li>可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li><li>https是现行架构下较安全的解决方案，增加了中间人攻击的成本。</li></ul><h2 id="HTTPS-协议的缺点"><a href="#HTTPS-协议的缺点" class="headerlink" title="HTTPS 协议的缺点"></a>HTTPS 协议的缺点</h2><ul><li>https 握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。</li><li>https 缓存不如 http 高效，会增加数据开销。</li><li>SSL 证书收钱，功能越强大的证书费用越高。</li><li>SSL 证书需要绑定 ip，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。</li><li>HTTPS 协议的加密范围也比较有限。</li></ul><h2 id="什么是-HTTP-协议无状态协议？怎么解决？"><a href="#什么是-HTTP-协议无状态协议？怎么解决？" class="headerlink" title="什么是 HTTP 协议无状态协议？怎么解决？"></a>什么是 HTTP 协议无状态协议？怎么解决？</h2><ul><li><p>无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息也就是说，当客户端一次 HTTP 请求完成以后，客户端再发送一次 HTTP 请求，HTTP 并不知道当前客户端是一个”老用户“。</p></li><li><p>可以使用 Cookie 来解决无状态的问题，Cookie 就相当于一个通行证，第一次访问的时候给客户端发送一个 Cookie，当客户端再次来的时候，拿着 Cookie (通行证)，那么服务器就知道这个是”老用户“。</p></li></ul><h2 id="常用的-HTTP-方法有哪些"><a href="#常用的-HTTP-方法有哪些" class="headerlink" title="常用的 HTTP 方法有哪些"></a>常用的 HTTP 方法有哪些</h2><ul><li>GET：用于请求访问已经被 URL（统一资源标识符）识别的资源，可以通过 URL 传参给服务器。</li><li>POST：用于传输信息给服务器，主要功能与 GET 方法类似，但一般推荐 POST 方式。</li><li>PUT：传输文件，报文主体包含文件内容，保存到对应 URL 位置。</li><li>HEAD：获取报文首部，与 GET 方法类似，只是不返回报文主体，一般用于验证 URL 是否有效。</li><li>DELET：删除文件，与 PUT 方法相反，删除对应 URL 位置的文件。</li><li>OPTIONS：查询相应 URL 支持的 HTTP 方法。</li></ul><h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><ul><li><p>TCP 是面向连接的，UDP 是无连接的即发送数据前不需要先建立链接。</p></li><li><p>TCP 提供可靠的服务，UDP 尽最大努力交付，不保证可靠交付。 </p></li><li><p>TCP 是面向字节流，UDP 面向报文，具有较好的实时性，工作效率比TCP高，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。</p></li><li><p>TCP 只能是一对一的，UDP 支持一对一，一对多，多对一，多对多。</p></li><li><p>TCP 的首部较大为20字节，而 UDP 只有8字节。</p></li></ul><h2 id="常见的-HTTP-的头部"><a href="#常见的-HTTP-的头部" class="headerlink" title="常见的 HTTP 的头部"></a>常见的 HTTP 的头部</h2><p>可以将 HTTP 首部分为通用首部，请求首部，响应首部，实体首部</p><ul><li><p>通用首部表示一些通用信息，比如 date 表示报文创建时间。</p></li><li><p>请求首部就是请求报文中独有的，如 cookie，和缓存相关的如 if-Modified-Since。</p></li><li><p>响应首部就是响应报文中独有的，如 set-cookie，和重定向相关的 location。</p></li><li><p>实体首部用来描述实体部分，如 allow 用来描述可执行的请求方法，content-type 描述主题类型，content-Encoding 描述主体的编码方式。</p></li></ul><h2 id="csrf-和-xss-的网络攻击及防范"><a href="#csrf-和-xss-的网络攻击及防范" class="headerlink" title="csrf 和 xss 的网络攻击及防范"></a>csrf 和 xss 的网络攻击及防范</h2><ul><li><p>CSRF：跨站请求伪造，可以理解为攻击者盗用了用户的身份，以用户的名义发送了恶意请求，比如用户登录了一个网站后，立刻在另一个 tab 页面访问量攻击者用来制造攻击的网站，这个网站要求访问刚刚登陆的网站，并发送了一个恶意请求，这时候 CSRF 就产生了，比如这个制造攻击的网站使用一张图片，但是这种图片的链接却是可以修改数据库的，这时候攻击者就可以以用户的名义操作这个数据库，防御方式的话：使用验证码，检查 https 头部的 refer，使用 token。</p></li><li><p>XSS：跨站脚本攻击，是说攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击，比如获取 cookie，或者其他用户身份信息，可以分为存储型和反射型，存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击，反射型的话不存储在数据库中，往往表现为将攻击代码放在 url 地址的请求参数中，防御的话为 cookie 设置 httpOnly 属性，对用户的输入进行检查，进行特殊字符过滤。</p></li></ul><h2 id="强缓存和协商缓存"><a href="#强缓存和协商缓存" class="headerlink" title="强缓存和协商缓存"></a>强缓存和协商缓存</h2><p>缓存分为两种：强缓存和协商缓存，根据响应的 header 内容来决定。</p><table><thead><tr><th></th><th>获取资源形式</th><th>状态码</th><th>发送请求到服务器</th></tr></thead><tbody><tr><td>强缓存</td><td>从缓存取</td><td>200（from cache）</td><td>否，直接从缓存取</td></tr><tr><td>协商缓存</td><td>从缓存取</td><td>304（not modified）</td><td>是，通过服务器来告知缓存是否可用</td></tr></tbody></table><ul><li><p>强缓存相关字段有 expires，cache-control。同时存在，cache-control 的优先级高</p></li><li><p>协商缓存相关字段有 Last-Modified/If-Modified-Since，Etag/If-None-Match</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>知识复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NetWork</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown数学公式语法</title>
    <link href="/2020/04/06/2020-4-6-Markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%AF%AD%E6%B3%95/"/>
    <url>/2020/04/06/2020-4-6-Markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="行内与独行"><a href="#行内与独行" class="headerlink" title="行内与独行"></a>行内与独行</h1><ol><li> 行内公式：将公式插入到本行内，符号：<code>$公式内容$</code>，如：$xyz$</li><li> 独行公式：将公式插入到新的一行内，并且居中，符号：<code>$$公式内容$$</code>，如：$$xyz$$</li></ol><h1 id="上标、下标与组合"><a href="#上标、下标与组合" class="headerlink" title="上标、下标与组合"></a>上标、下标与组合</h1><ol><li> 上标符号，符号：<code>^</code>，如：$x^4$</li><li> 下标符号，符号：<code>_</code>，如：$x_1$</li><li> 组合符号，符号：<code>&#123;&#125;</code>，如：${16}<em>{8}O{2+}</em>{2}$</li></ol><h1 id="汉字、字体与格式"><a href="#汉字、字体与格式" class="headerlink" title="汉字、字体与格式"></a>汉字、字体与格式</h1><ol><li> 汉字形式，符号：<code>\mbox&#123;&#125;</code>，如：$V_{\mbox{初始}}$</li><li> 字体控制，符号：<code>\displaystyle</code>，如：$\displaystyle \frac{x+y}{y+z}$</li><li> 下划线符号，符号：<code>\underline</code>，如：$\underline{x+y}$</li><li> 标签，符号<code>\tag&#123;数字&#125;</code>，如：$\tag{11}$</li><li> 上大括号，符号：<code>\overbrace&#123;算式&#125;</code>，如：$\overbrace{a+b+c+d}^{2.0}$</li><li> 下大括号，符号：<code>\underbrace&#123;算式&#125;</code>，如：$a+\underbrace{b+c}_{1.0}+d$</li><li> 上位符号，符号：<code>\stacrel&#123;上位符号&#125;&#123;基位符号&#125;</code>，如：$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$</li></ol><h1 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h1><ol><li> 两个quad空格，符号：<code>\qquad</code>，如：$x \qquad y$</li><li> quad空格，符号：<code>\quad</code>，如：$x \quad y$</li><li> 大空格，符号<code>\</code>，如：$x \  y$</li><li> 中空格，符号<code>\:</code>，如：$x : y$</li><li> 小空格，符号<code>\,</code>，如：$x , y$</li><li> 没有空格，符号``，如：$xy$</li><li> 紧贴，符号<code>\!</code>，如：$x ! y$</li></ol><h1 id="定界符与组合"><a href="#定界符与组合" class="headerlink" title="定界符与组合"></a>定界符与组合</h1><ol><li> 括号，符号：<code>（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)</code>，如：$（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$</li><li> 中括号，符号：<code>[]</code>，如：$[x+y]$</li><li> 大括号，符号：<code>\&#123; \&#125;</code>，如：${x+y}$</li><li> 自适应括号，符号：<code>\left \right</code>，如：$\left(x\right)$，$\left(x{yz}\right)$</li><li> 组合公式，符号：<code>&#123;上位公式 \choose 下位公式&#125;</code>，如：${n+1 \choose k}={n \choose k}+{n \choose k-1}$</li><li> 组合公式，符号：<code>&#123;上位公式 \atop 下位公式&#125;</code>，如：$\sum_{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n}A_{k_0}A_{k_1}\cdots$</li></ol><h1 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h1><ol><li> 加法运算，符号：<code>+</code>，如：$x+y=z$</li><li> 减法运算，符号：<code>-</code>，如：$x-y=z$</li><li> 加减运算，符号：<code>\pm</code>，如：$x \pm y=z$</li><li> 减甲运算，符号：<code>\mp</code>，如：$x \mp y=z$</li><li> 乘法运算，符号：<code>\times</code>，如：$x \times y=z$</li><li> 点乘运算，符号：<code>\cdot</code>，如：$x \cdot y=z$</li><li> 星乘运算，符号：<code>\ast</code>，如：$x \ast y=z$</li><li> 除法运算，符号：<code>\div</code>，如：$x \div y=z$</li><li> 斜法运算，符号：<code>/</code>，如：$x/y=z$</li><li> 分式表示，符号：<code>\frac&#123;分子&#125;&#123;分母&#125;</code>，如：$\frac{x+y}{y+z}$</li><li> 分式表示，符号：<code>&#123;分子&#125; \voer &#123;分母&#125;</code>，如：${x+y} \over {y+z}$</li><li> 绝对值表示，符号：<code>||</code>，如：$|x+y|$</li></ol><h1 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h1><ol><li> 平均数运算，符号：<code>\overline&#123;算式&#125;</code>，如：$\overline{xyz}$</li><li> 开二次方运算，符号：<code>\sqrt</code>，如：$\sqrt x$</li><li> 开方运算，符号：<code>\sqrt[开方数]&#123;被开方数&#125;</code>，如：$\sqrt[3]{x+y}$</li><li> 对数运算，符号：<code>\log</code>，如：$\log(x)$</li><li> 极限运算，符号：<code>\lim</code>，如：$\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li> 极限运算，符号：<code>\displaystyle \lim</code>，如：$\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li> 求和运算，符号：<code>\sum</code>，如：$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li> 求和运算，符号：<code>\displaystyle \sum</code>，如：$\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li> 积分运算，符号：<code>\int</code>，如：$\int^{\infty}_{0}{xdx}$</li><li> 积分运算，符号：<code>\displaystyle \int</code>，如：$\displaystyle \int^{\infty}_{0}{xdx}$</li><li> 微分运算，符号：<code>\partial</code>，如：$\frac{\partial x}{\partial y}$</li><li> 矩阵表示，符号：<code>\begin&#123;matrix&#125; \end&#123;matrix&#125;</code>，如：$\left[ \begin{matrix} 1 &amp;2 &amp;\cdots &amp;4\5 &amp;6 &amp;\cdots &amp;8\vdots &amp;\vdots &amp;\ddots &amp;\vdots\13 &amp;14 &amp;\cdots &amp;16\end{matrix} \right]$</li></ol><h1 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h1><ol><li> 等于运算，符号：<code>=</code>，如：$x+y=z$</li><li> 大于运算，符号：<code>&gt;</code>，如：$x+y&gt;z$</li><li> 小于运算，符号：<code>&lt;</code>，如：$x+y&lt;z$</li><li> 大于等于运算，符号：<code>\geq</code>，如：$x+y \geq z$</li><li> 小于等于运算，符号：<code>\leq</code>，如：$x+y \leq z$</li><li> 不等于运算，符号：<code>\neq</code>，如：$x+y \neq z$</li><li> 不大于等于运算，符号：<code>\ngeq</code>，如：$x+y \ngeq z$</li><li> 不大于等于运算，符号：<code>\not\geq</code>，如：$x+y \not\geq z$</li><li> 不小于等于运算，符号：<code>\nleq</code>，如：$x+y \nleq z$</li><li> 不小于等于运算，符号：<code>\not\leq</code>，如：$x+y \not\leq z$</li><li> 约等于运算，符号：<code>\approx</code>，如：$x+y \approx z$</li><li> 恒定等于运算，符号：<code>\equiv</code>，如：$x+y \equiv z$</li></ol><h1 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h1><ol><li> 属于运算，符号：<code>\in</code>，如：$x \in y$</li><li> 不属于运算，符号：<code>\notin</code>，如：$x \notin y$</li><li> 不属于运算，符号：<code>\not\in</code>，如：$x \not\in y$</li><li> 子集运算，符号：<code>\subset</code>，如：$x \subset y$</li><li> 子集运算，符号：<code>\supset</code>，如：$x \supset y$</li><li> 真子集运算，符号：<code>\subseteq</code>，如：$x \subseteq y$</li><li> 非真子集运算，符号：<code>\subsetneq</code>，如：$x \subsetneq y$</li><li> 真子集运算，符号：<code>\supseteq</code>，如：$x \supseteq y$</li><li> 非真子集运算，符号：<code>\supsetneq</code>，如：$x \supsetneq y$</li><li> 非子集运算，符号：<code>\not\subset</code>，如：$x \not\subset y$</li><li> 非子集运算，符号：<code>\not\supset</code>，如：$x \not\supset y$</li><li> 并集运算，符号：<code>\cup</code>，如：$x \cup y$</li><li> 交集运算，符号：<code>\cap</code>，如：$x \cap y$</li><li> 差集运算，符号：<code>\setminus</code>，如：$x \setminus y$</li><li> 同或运算，符号：<code>\bigodot</code>，如：$x \bigodot y$</li><li> 同与运算，符号：<code>\bigotimes</code>，如：$x \bigotimes y$</li><li> 实数集合，符号：<code>\mathbb&#123;R&#125;</code>，如：<code>\mathbb&#123;R&#125;</code> </li><li> 自然数集合，符号：<code>\mathbb&#123;Z&#125;</code>，如：<code>\mathbb&#123;Z&#125;</code> </li><li> 空集，符号：<code>\emptyset</code>，如：$\emptyset$</li></ol><h1 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h1><ol><li> 无穷，符号：<code>\infty</code>，如：$\infty$</li><li> 虚数，符号：<code>\imath</code>，如：$\imath$</li><li> 虚数，符号：<code>\jmath</code>，如：$\jmath$</li><li> 数学符号，符号<code>\hat&#123;a&#125;</code>，如：$\hat{a}$</li><li> 数学符号，符号<code>\check&#123;a&#125;</code>，如：$\check{a}$</li><li> 数学符号，符号<code>\breve&#123;a&#125;</code>，如：$\breve{a}$</li><li> 数学符号，符号<code>\tilde&#123;a&#125;</code>，如：$\tilde{a}$</li><li> 数学符号，符号<code>\bar&#123;a&#125;</code>，如：$\bar{a}$</li><li> 矢量符号，符号<code>\vec&#123;a&#125;</code>，如：$\vec{a}$</li><li> 数学符号，符号<code>\acute&#123;a&#125;</code>，如：$\acute{a}$</li><li> 数学符号，符号<code>\grave&#123;a&#125;</code>，如：$\grave{a}$</li><li> 数学符号，符号<code>\mathring&#123;a&#125;</code>，如：$\mathring{a}$</li><li> 一阶导数符号，符号<code>\dot&#123;a&#125;</code>，如：$\dot{a}$</li><li> 二阶导数符号，符号<code>\ddot&#123;a&#125;</code>，如：$\ddot{a}$</li><li> 上箭头，符号：<code>\uparrow</code>，如：$\uparrow$</li><li> 上箭头，符号：<code>\Uparrow</code>，如：$\Uparrow$</li><li> 下箭头，符号：<code>\downarrow</code>，如：$\downarrow$</li><li> 下箭头，符号：<code>\Downarrow</code>，如：$\Downarrow$</li><li> 左箭头，符号：<code>\leftarrow</code>，如：$\leftarrow$</li><li> 左箭头，符号：<code>\Leftarrow</code>，如：$\Leftarrow$</li><li> 右箭头，符号：<code>\rightarrow</code>，如：$\rightarrow$</li><li> 右箭头，符号：<code>\Rightarrow</code>，如：$\Rightarrow$</li><li> 底端对齐的省略号，符号：<code>\ldots</code>，如：$1,2,\ldots,n$</li><li> 中线对齐的省略号，符号：<code>\cdots</code>，如：$x_1^2 + x_2^2 + \cdots + x_n^2$</li><li> 竖直对齐的省略号，符号：<code>\vdots</code>，如：$\vdots$</li><li> 斜对齐的省略号，符号：<code>\ddots</code>，如：$\ddots$</li></ol><h1 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h1><table><thead><tr><th>字母</th><th>实现</th><th>字母</th><th>实现</th></tr></thead><tbody><tr><td>A</td><td><code>A</code></td><td>α</td><td><code>\alhpa</code></td></tr><tr><td>B</td><td><code>B</code></td><td>β</td><td><code>\beta</code></td></tr><tr><td>Γ</td><td><code>\Gamma</code></td><td>γ</td><td><code>\gamma</code></td></tr><tr><td>Δ</td><td><code>\Delta</code></td><td>δ</td><td><code>\delta</code></td></tr><tr><td>E</td><td><code>E</code></td><td>ϵ</td><td><code>\epsilon</code></td></tr><tr><td>Z</td><td><code>Z</code></td><td>ζ</td><td><code>\zeta</code></td></tr><tr><td>H</td><td><code>H</code></td><td>η</td><td><code>\eta</code></td></tr><tr><td>Θ</td><td><code>\Theta</code></td><td>θ</td><td><code>\theta</code></td></tr><tr><td>I</td><td><code>I</code></td><td>ι</td><td><code>\iota</code></td></tr><tr><td>K</td><td><code>K</code></td><td>κ</td><td><code>\kappa</code></td></tr><tr><td>Λ</td><td><code>\Lambda</code></td><td>λ</td><td><code>\lambda</code></td></tr><tr><td>M</td><td><code>M</code></td><td>μ</td><td><code>\mu</code></td></tr><tr><td>N</td><td><code>N</code></td><td>ν</td><td><code>\nu</code></td></tr><tr><td>Ξ</td><td><code>\Xi</code></td><td>ξ</td><td><code>\xi</code></td></tr><tr><td>O</td><td><code>O</code></td><td>ο</td><td><code>\omicron</code></td></tr><tr><td>Π</td><td><code>\Pi</code></td><td>π</td><td><code>\pi</code></td></tr><tr><td>P</td><td><code>P</code></td><td>ρ</td><td><code>\rho</code></td></tr><tr><td>Σ</td><td><code>\Sigma</code></td><td>σ</td><td><code>\sigma</code></td></tr><tr><td>T</td><td><code>T</code></td><td>τ</td><td><code>\tau</code></td></tr><tr><td>Υ</td><td><code>\Upsilon</code></td><td>υ</td><td><code>\upsilon</code></td></tr><tr><td>Φ</td><td><code>\Phi</code></td><td>ϕ</td><td><code>\phi</code></td></tr><tr><td>X</td><td><code>X</code></td><td>χ</td><td><code>\chi</code></td></tr><tr><td>Ψ</td><td><code>\Psi</code></td><td>ψ</td><td><code>\psi</code></td></tr><tr><td>Ω</td><td><code>\v</code></td><td>ω</td><td><code>\omega</code></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TensorFlow基础</title>
    <link href="/2020/03/29/2020-3-29-TensorFlow%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/03/29/2020-3-29-TensorFlow%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><ul><li>  标量（Scalar），单个实数，如1.2,3,4等，维度（Dimension）数为0，shape为[]。</li></ul><pre><code class="hljs python"><span class="hljs-comment"># python 语言创建标量</span>a = <span class="hljs-number">1.2</span><span class="hljs-comment"># TensorFlow 创建标量</span>aa = tf.constant(<span class="hljs-number">1.2</span>)print(<span class="hljs-built_in">type</span>(a), <span class="hljs-built_in">type</span>(aa), tf.is_tensor(a))<span class="hljs-comment">#&lt;class &#x27;float&#x27;&gt; &lt;class &#x27;tensorflow.python.framework.ops.EagerTensor&#x27;&gt; False</span></code></pre><ul><li>  向量（Vector），n个实数的有序集合，如[1.2]，[1, 2, 3, 4]等，维度为1，长度不定。</li></ul><pre><code class="hljs python"><span class="hljs-comment"># 创建1个元素的向量</span>a = tf.constant([<span class="hljs-number">1.1</span>])print(a, a.shape)<span class="hljs-comment"># 创建3个元素的向量</span>b = tf.constant([<span class="hljs-number">1.</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3.3</span>])print(b, b.shape)<span class="hljs-comment">#tf.Tensor([1.1], shape=(1,), dtype=float32) (1,)</span><span class="hljs-comment">#tf.Tensor([1.  2.  3.3], shape=(3,), dtype=float32) (3,)</span></code></pre><ul><li>  矩阵（Matrix），n行m列实数集合，如[[1, 2], [3, 4]]</li></ul><pre><code class="hljs python"><span class="hljs-comment"># 创建2行2列的矩阵</span>c = tf.constant([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]])print(c, c.shape)<span class="hljs-comment">#tf.Tensor(</span><span class="hljs-comment">#[[1 2]</span><span class="hljs-comment"># [3 4]], shape=(2, 2), dtype=int32) (2, 2)</span></code></pre><ul><li>  张量（Tensor），所有维度数大于2的数组统称张量。</li></ul><pre><code class="hljs python">x = tf.constant([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3.0</span>])print(x)<span class="hljs-comment"># 将 tf 张量的数据导出为 numpy 数组格式</span>print(x.numpy())<span class="hljs-comment">#tf.Tensor([1. 2. 3.], shape=(3,), dtype=float32)</span><span class="hljs-comment">#[1. 2. 3.]</span></code></pre><h2 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h2><pre><code class="hljs python"><span class="hljs-comment"># 创建字符串</span>s = tf.constant(<span class="hljs-string">&#x27;Hello World!&#x27;</span>)print(s)<span class="hljs-comment"># 小写化字符串</span>s = tf.strings.lower(s)print(s)<span class="hljs-comment">#tf.Tensor(b&#x27;Hello World!&#x27;, shape=(), dtype=string)</span><span class="hljs-comment">#tf.Tensor(b&#x27;hello world!&#x27;, shape=(), dtype=string)</span></code></pre><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><pre><code class="hljs python"><span class="hljs-comment"># 创建布尔型标量</span>a = tf.constant(<span class="hljs-literal">True</span>)print(a)<span class="hljs-comment"># 创建布尔型向量</span>b = tf.constant([<span class="hljs-literal">True</span>, <span class="hljs-literal">False</span>])print(b)<span class="hljs-comment">#tf.Tensor(True, shape=(), dtype=bool)</span><span class="hljs-comment">#tf.Tensor([ True False], shape=(2,), dtype=bool)</span></code></pre><h1 id="数值精度"><a href="#数值精度" class="headerlink" title="数值精度"></a>数值精度</h1><pre><code class="hljs python"><span class="hljs-comment"># 创建指定的张量</span>a = tf.constant(<span class="hljs-number">123456789</span>, dtype=tf.int16)print(a)b = tf.constant(<span class="hljs-number">123456789</span>, dtype=tf.int32)print(b)<span class="hljs-comment">#tf.Tensor(-13035, shape=(), dtype=int16)</span><span class="hljs-comment">#tf.Tensor(123456789, shape=(), dtype=int32)</span></code></pre><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment"># np.pi 从 numpy 中导入 pi 常量</span><span class="hljs-comment"># 32位</span>a = tf.constant(np.pi, dtype=tf.float32)print(a)<span class="hljs-comment"># 64位</span>b = tf.constant(np.pi, dtype=tf.float64)print(b)<span class="hljs-comment">#tf.Tensor(3.1415927, shape=(), dtype=float32)</span><span class="hljs-comment">#tf.Tensor(3.141592653589793, shape=(), dtype=float64)</span></code></pre><h2 id="读取精度"><a href="#读取精度" class="headerlink" title="读取精度"></a>读取精度</h2><p>通过访问张量的 dtype 成员属性可以判断张量的保存精度</p><pre><code class="hljs python">a = tf.constant(np.pi, dtype=tf.float16)<span class="hljs-comment"># 读取原有张量的数值精度</span>print(<span class="hljs-string">&#x27;before:&#x27;</span>, a.dtype)<span class="hljs-comment"># 如果精度不符合要求，则进行转换</span><span class="hljs-keyword">if</span> a.dtype != tf.float32:    <span class="hljs-comment"># tf.cast 函数可以完成精度转换</span>    a = tf.cast(a, tf.float32)<span class="hljs-comment"># 打印转换后的精度</span>print(<span class="hljs-string">&#x27;after :&#x27;</span>, a.dtype)<span class="hljs-comment">#before: &lt;dtype: &#x27;float16&#x27;&gt;</span><span class="hljs-comment">#after : &lt;dtype: &#x27;float32&#x27;&gt;</span></code></pre><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>通过 tf.cast 函数进行转换</p><pre><code class="hljs python"><span class="hljs-comment"># 创建tf.float16 低精度张量</span>a = tf.constant(np.pi, dtype=tf.float16)<span class="hljs-comment"># 转换为高精度张量</span>tf.cast(a, tf.double)<span class="hljs-comment">#Out[32]: &lt;tf.Tensor: shape=(), dtype=float64, numpy=3.140625&gt;</span></code></pre><p>进行类型转换时，需要保证转换操作的合法性，例如将高精度的张量转换为低精度的张量<br>时，可能发生数据溢出隐患：</p><pre><code class="hljs python">a = tf.constant(<span class="hljs-number">123456789</span>, dtype=tf.int32)<span class="hljs-comment"># 转换为低精度整型</span>tf.cast(a, tf.int16)<span class="hljs-comment">#Out[33]: &lt;tf.Tensor: shape=(), dtype=int16, numpy=-13035&gt;</span></code></pre><h1 id="待优化张量"><a href="#待优化张量" class="headerlink" title="待优化张量"></a>待优化张量</h1><p>为了区分需要计算梯度信息的张量与不需要计算梯度信息的张量，TensorFlow 增加了一种专门的数据类型来支持梯度信息的记录：tf.Variable。tf.Variable 类型在普通的张量类型基础上添加了name，trainable 等属性来支持计算图的构建。由于梯度运算会消耗大量的计算资源，而且会自动更新相关参数，对于不需要的优化的张量，如神经网络的输入𝑿，不需要通过tf.Variable 封装；相反，对于需要计算梯度并优化的张量，如神经网络层的𝑾和𝒃，需要通过tf.Variable 包裹以便TensorFlow 跟踪相关梯度信息。</p><pre><code class="hljs python"><span class="hljs-comment"># 创建TF 张量</span>a = tf.constant([-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<span class="hljs-comment"># 转换为Variable 类型</span>aa = tf.Variable(a)<span class="hljs-comment"># Variable 类型张量的属性</span>aa.name, aa.trainable<span class="hljs-comment">#Out[35]: (&#x27;Variable:0&#x27;, True)</span></code></pre><p>其中张量的name 和trainable 属性是Variable 特有的属性，name 属性用于命名计算图中的变量，这套命名体系是 TensorFlow 内部维护的，一般不需要用户关注name 属性；trainable 属性表征当前张量是否需要被优化，创建 Variable 对象时是默认启用优化标志，可以设置 trainable=False 来设置张量不需要优化。</p><p>除了通过普通张量方式创建Variable，也可以直接创建，例如：</p><pre><code class="hljs python"><span class="hljs-comment"># 直接创建Variable 张量</span>tf.Variable([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]])<span class="hljs-comment">#&lt;tf.Variable &#x27;Variable:0&#x27; shape=(2, 2) dtype=int32, numpy=</span><span class="hljs-comment">#array([[1, 2],</span><span class="hljs-comment">#       [3, 4]])&gt;</span></code></pre><h1 id="创建张量"><a href="#创建张量" class="headerlink" title="创建张量"></a>创建张量</h1><h2 id="从数组、列表对象创建"><a href="#从数组、列表对象创建" class="headerlink" title="从数组、列表对象创建"></a>从数组、列表对象创建</h2><p>通过 tf.convert_to_tensor 函数可以创建新Tensor，并将保存在Python List 对象或者 Numpy Array 对象中的数据导入到新Tensor 中，例如：</p><pre><code class="hljs python"><span class="hljs-comment"># 从列表创建张量</span>tf.convert_to_tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2.</span>])<span class="hljs-comment"># 从数组中创建张量</span>tf.convert_to_tensor(np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2.</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]))<span class="hljs-comment">#Out[39]: &lt;tf.Tensor: shape=(2,), dtype=float32, numpy=array([1., 2.], dtype=float32)&gt;</span><span class="hljs-comment">#Out[40]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(2, 2), dtype=float64, numpy=</span><span class="hljs-comment">#array([[1., 2.],</span><span class="hljs-comment">#       [3., 4.]])&gt;</span></code></pre><h2 id="创建全0-或全1-张量"><a href="#创建全0-或全1-张量" class="headerlink" title="创建全0 或全1 张量"></a>创建全0 或全1 张量</h2><p>通过 tf.zeros() 和 tf.ones() 即可创建任意形状，且内容全0 或全1 的张量。</p><p>创建为0 和为1 的标量：</p><pre><code class="hljs python"><span class="hljs-comment"># 创建全0，全1 的标量</span>tf.zeros([]), tf.ones([])<span class="hljs-comment">#Out[43]: </span><span class="hljs-comment">#(&lt;tf.Tensor: shape=(), dtype=float32, numpy=0.0&gt;,</span><span class="hljs-comment"># &lt;tf.Tensor: shape=(), dtype=float32, numpy=1.0&gt;)</span></code></pre><p>创建全 0 和全1 的向量：</p><pre><code class="hljs python"><span class="hljs-comment"># 创建全0，全1 的向量</span>tf.zeros([<span class="hljs-number">1</span>]), tf.ones([<span class="hljs-number">1</span>])<span class="hljs-comment">#Out[44]: </span><span class="hljs-comment">#(&lt;tf.Tensor: shape=(1,), dtype=float32, numpy=array([0.], dtype=float32)&gt;,</span><span class="hljs-comment"># &lt;tf.Tensor: shape=(1,), dtype=float32, numpy=array([1.], dtype=float32)&gt;)</span></code></pre><p>创建全 0 和全1 的矩阵：</p><pre><code class="hljs python"><span class="hljs-comment"># 创建全 0 和全1 的矩阵</span>tf.zeros([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>]), tf.ones([<span class="hljs-number">3</span>, <span class="hljs-number">2</span>])<span class="hljs-comment">#Out[45]: </span><span class="hljs-comment">#(&lt;tf.Tensor: shape=(2, 2), dtype=float32, numpy=</span><span class="hljs-comment"># array([[0., 0.],</span><span class="hljs-comment">#        [0., 0.]], dtype=float32)&gt;,</span><span class="hljs-comment"># &lt;tf.Tensor: shape=(3, 2), dtype=float32, numpy=</span><span class="hljs-comment"># array([[1., 1.],</span><span class="hljs-comment">#        [1., 1.],</span><span class="hljs-comment">#        [1., 1.]], dtype=float32)&gt;)</span></code></pre><p>通过 tf.zeros_like，tf.ones_like 可以方便地<strong>新建</strong>与某个张量shape 一致，且内容为全0 或全1 的张量。</p><pre><code class="hljs python"><span class="hljs-comment"># 创建一个矩阵</span>a = tf.ones([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<span class="hljs-comment"># 创建一个矩阵</span>b = tf.zeros([<span class="hljs-number">3</span>, <span class="hljs-number">2</span>])<span class="hljs-comment"># 创建一个与a 形状相同，但是全0 的新矩阵</span>tf.zeros_like(a), tf.ones_like(a)<span class="hljs-comment">#Out[47]: </span><span class="hljs-comment">#(&lt;tf.Tensor: shape=(2, 3), dtype=float32, numpy=</span><span class="hljs-comment"># array([[0., 0., 0.],</span><span class="hljs-comment">#        [0., 0., 0.]], dtype=float32)&gt;,</span><span class="hljs-comment"># &lt;tf.Tensor: shape=(2, 3), dtype=float32, numpy=</span><span class="hljs-comment"># array([[1., 1., 1.],</span><span class="hljs-comment">#        [1., 1., 1.]], dtype=float32)&gt;)</span></code></pre><h2 id="创建自定义数值张量"><a href="#创建自定义数值张量" class="headerlink" title="创建自定义数值张量"></a>创建自定义数值张量</h2><pre><code class="hljs python"><span class="hljs-comment"># 创建-1 的标量</span>tf.fill([], -<span class="hljs-number">1</span>)<span class="hljs-comment">#Out[48]: &lt;tf.Tensor: shape=(), dtype=int32, numpy=-1&gt;</span><span class="hljs-comment"># 创建-1 的向量</span>tf.fill([<span class="hljs-number">1</span>], -<span class="hljs-number">1</span>)<span class="hljs-comment">#Out[49]: &lt;tf.Tensor: shape=(1,), dtype=int32, numpy=array([-1])&gt;</span><span class="hljs-comment"># 创建2 行2 列，元素全为99 的矩阵</span>tf.fill([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], <span class="hljs-number">99</span>)<span class="hljs-comment">#Out[50]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(2, 2), dtype=int32, numpy=</span><span class="hljs-comment">#array([[99, 99],</span><span class="hljs-comment">#       [99, 99]])&gt;</span></code></pre><h2 id="创建已知分布的张量"><a href="#创建已知分布的张量" class="headerlink" title="创建已知分布的张量"></a>创建已知分布的张量</h2><p>通过 tf.random.normal(shape, mean=0.0, stddev = 1.0)可以创建形状为shape，均值为 mean，标准差为stddev 的正态分布𝒩(mean, stddev2)。</p><pre><code class="hljs python"><span class="hljs-comment"># 创建标准正态分布的张量</span>tf.random.normal([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>])<span class="hljs-comment">#Out[51]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(2, 2), dtype=float32, numpy=</span><span class="hljs-comment">#array([[ 0.5267555 ,  1.0245267 ],</span><span class="hljs-comment">#       [-0.38253555, -1.3879421 ]], dtype=float32)&gt;</span><span class="hljs-comment"># 创建均值为1，标准差为2 的正态分布</span>tf.random.normal([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], mean=<span class="hljs-number">1</span>, stddev=<span class="hljs-number">2</span>)<span class="hljs-comment">#Out[52]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(2, 2), dtype=float32, numpy=</span><span class="hljs-comment">#array([[-1.3101618,  2.3768656],</span><span class="hljs-comment">#       [ 3.5436885,  1.8762882]], dtype=float32)&gt;</span></code></pre><p>通过 tf.random.uniform(shape, minval=0, maxval=None, dtype=tf.float32)可以创建采样自[minval, maxval)区间的均匀分布的张量。</p><pre><code class="hljs python"><span class="hljs-comment"># 创建采样自[0,1)均匀分布的矩阵</span>tf.random.uniform([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>])<span class="hljs-comment">#Out[53]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(2, 2), dtype=float32, numpy=</span><span class="hljs-comment">#array([[0.54303396, 0.8830224 ],</span><span class="hljs-comment">#       [0.29734194, 0.94715846]], dtype=float32)&gt;</span><span class="hljs-comment"># 创建采样自区间[0,10)，shape 为[2,2]的矩阵</span>tf.random.uniform([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], maxval=<span class="hljs-number">10</span>)<span class="hljs-comment">#Out[58]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(2, 2), dtype=float32, numpy=</span><span class="hljs-comment">#array([[5.781268 , 8.726329 ],</span><span class="hljs-comment">#       [1.5149117, 8.840149 ]], dtype=float32)&gt;</span></code></pre><p>如果需要均匀采样整形类型的数据，必须指定采样区间的最大值 maxval 参数，同时指定数据类型为 tf.int* 型：</p><pre><code class="hljs python"><span class="hljs-comment"># 创建采样自[0,100)均匀分布的整型矩阵</span>tf.random.uniform([<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], maxval=<span class="hljs-number">100</span>, dtype=tf.int32)<span class="hljs-comment">#Out[59]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(2, 2), dtype=int32, numpy=</span><span class="hljs-comment">#array([[76, 86],</span><span class="hljs-comment">#       [53, 28]])&gt;</span></code></pre><h2 id="创建序列"><a href="#创建序列" class="headerlink" title="创建序列"></a>创建序列</h2><pre><code class="hljs python"><span class="hljs-comment"># 0~10，不包含10</span>tf.<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)<span class="hljs-comment">#Out[60]: &lt;tf.Tensor: shape=(10,), dtype=int32, numpy=array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;</span><span class="hljs-comment"># 0~10，步长为2</span>tf.<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>, delta=<span class="hljs-number">2</span>)<span class="hljs-comment">#Out[61]: &lt;tf.Tensor: shape=(5,), dtype=int32, numpy=array([0, 2, 4, 6, 8])&gt;</span><span class="hljs-comment"># 2~10</span>tf.<span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, delta=<span class="hljs-number">2</span>)<span class="hljs-comment">#Out[62]: &lt;tf.Tensor: shape=(4,), dtype=int32, numpy=array([2, 4, 6, 8])&gt;</span></code></pre><h1 id="索引与切片"><a href="#索引与切片" class="headerlink" title="索引与切片"></a>索引与切片</h1><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><pre><code class="hljs python"><span class="hljs-comment"># 创建4D张量</span>x = tf.random.normal([<span class="hljs-number">4</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">3</span>])<span class="hljs-comment"># 取第1张图片的数据</span>x[<span class="hljs-number">0</span>]<span class="hljs-comment">#Out[3]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(32, 32, 3), dtype=float32, numpy=</span><span class="hljs-comment">#array([[[-4.22283739e-01,  1.12282026e+00,  5.82848310e-01],</span><span class="hljs-comment">#        [-1.11039448e+00,  8.52484107e-01, -7.36349642e-01],</span><span class="hljs-comment">#        [-4.43234473e-01, -7.96303034e-01, -1.39369264e-01],</span><span class="hljs-comment">#        ...,</span><span class="hljs-comment">#        [ 3.56604964e-01,  1.80101013e+00,  1.25016725e+00],</span><span class="hljs-comment">#        [ 1.87405634e+00, -4.38889146e-01, -1.64619851e+00],</span><span class="hljs-comment">#        [ 1.48716550e-02,  9.12306726e-01, -1.21598518e+00]]],</span><span class="hljs-comment">#      dtype=float32)&gt;</span><span class="hljs-comment"># 取第1张图片的第2行</span>x[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<span class="hljs-comment">#Out[4]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(32, 3), dtype=float32, numpy=</span><span class="hljs-comment">#array([[ 1.5910356e+00, -8.5894281e-01,  4.5708373e-01],</span><span class="hljs-comment">#       [ 7.9057968e-01, -1.3268896e+00,  1.1165951e+00],</span><span class="hljs-comment">#       [ 9.6109343e-01,  2.2252908e-01, -7.0836329e-01],...,</span><span class="hljs-comment">#       [-5.8272004e-01,  7.4958265e-01, -3.2686439e-01]], dtype=float32)&gt;</span><span class="hljs-comment"># 取第1张图片的第2行的第3列</span>x[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">3</span>]<span class="hljs-comment">#Out[5]: &lt;tf.Tensor: shape=(3,), dtype=float32, numpy=array([-3.439938 ,  0.7158939, -0.2061273], dtype=float32)&gt;</span><span class="hljs-comment"># 取第3张图片，第2行，第1列的像素，B 通道(第2 个通道)颜色强度值</span>x[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<span class="hljs-comment">#Out[7]: &lt;tf.Tensor: shape=(), dtype=float32, numpy=1.1827037&gt;</span></code></pre><p>当张量的维度数较高时，使用[𝑖][𝑗]. . . [𝑘]的方式书写不方便，可以采用[𝑖, 𝑗, … , 𝑘]的方索引，它们是等价的。</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>通过start: end: step切片方式可以方便地提取一段数据，其中start 为开始读取位置的索引，end 为结束读取位置的索引(不包含end 位)，step 为采样步长。</p><pre><code class="hljs python"><span class="hljs-comment"># 创建4D张量</span>x = tf.random.normal([<span class="hljs-number">4</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">3</span>])<span class="hljs-comment"># 读取第2,3 张图片</span>x[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<span class="hljs-comment">#Out[8]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(2, 32, 32, 3), dtype=float32, numpy=</span><span class="hljs-comment">#array([[[[-0.5387477 , -0.98211324,  0.3736743 ],</span><span class="hljs-comment">#         [-1.5512782 , -1.2625393 ,  0.12689345],</span><span class="hljs-comment">#         [ 0.933382  ,  0.23778425, -1.4852659 ],</span><span class="hljs-comment">#         ...,</span></code></pre><p>start: end: step切片方式有很多简写方式，其中start、end、step 3 个参数可以根据需要选择性地省略，全部省略时即为::，表示从最开始读取到最末尾，步长为1，即不跳过任何元素。如x[0,::]表示读取第1 张图片的所有行，其中::表示在行维度上读取所有行，它等价于x[0]的写法：</p><pre><code class="hljs python"><span class="hljs-comment"># 取第1张图片</span>x[<span class="hljs-number">0</span>, ::]<span class="hljs-comment">#Out[9]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(32, 32, 3), dtype=float32, numpy=</span><span class="hljs-comment">#array([[[ 0.25870258,  0.20981076,  0.31078792],</span><span class="hljs-comment">#        [-0.17310825, -0.2321168 ,  1.4408395 ],</span><span class="hljs-comment">#        [ 0.47256398,  1.8767792 , -0.41517937],</span><span class="hljs-comment">#        ...,</span>x[:,<span class="hljs-number">0</span>:<span class="hljs-number">28</span>:<span class="hljs-number">2</span>, <span class="hljs-number">0</span>:<span class="hljs-number">28</span>:<span class="hljs-number">2</span>, :]<span class="hljs-comment">#Out[10]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(4, 14, 14, 3), dtype=float32, numpy=</span><span class="hljs-comment">#array([[[[ 0.25870258,  0.20981076,  0.31078792],</span><span class="hljs-comment">#         [ 0.47256398,  1.8767792 , -0.41517937],</span><span class="hljs-comment">#         [-1.4870992 ,  0.77554166,  0.74479437],</span><span class="hljs-comment">#         ...,</span></code></pre><pre><code class="hljs python"><span class="hljs-comment"># 创建0~9 向量</span>x = tf.<span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)<span class="hljs-comment"># 从8 取到0，逆序，不包含0</span>x[<span class="hljs-number">8</span>:<span class="hljs-number">0</span>:-<span class="hljs-number">1</span>] <span class="hljs-comment">#Out[11]: &lt;tf.Tensor: shape=(8,), dtype=int32, numpy=array([8, 7, 6, 5, 4, 3, 2, 1])&gt;</span><span class="hljs-comment"># 逆序全部元素</span>x[::-<span class="hljs-number">1</span>]<span class="hljs-comment">#Out[12]: &lt;tf.Tensor: shape=(9,), dtype=int32, numpy=array([8, 7, 6, 5, 4, 3, 2, 1, 0])&gt;</span><span class="hljs-comment"># 逆序间隔采样</span>x[::-<span class="hljs-number">2</span>]<span class="hljs-comment">#Out[13]: &lt;tf.Tensor: shape=(5,), dtype=int32, numpy=array([8, 6, 4, 2, 0])&gt;</span></code></pre><p>读取每张图片的所有通道，其中行按着逆序隔行采样，列按着逆序隔行采样，实现如下：</p><pre><code class="hljs python"><span class="hljs-comment"># 创建4D张量</span>x = tf.random.normal([<span class="hljs-number">4</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">3</span>])<span class="hljs-comment"># 行、列逆序间隔采样</span>x[<span class="hljs-number">0</span>, ::-<span class="hljs-number">2</span>, ::-<span class="hljs-number">2</span>]<span class="hljs-comment">#Out[14]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(16, 16, 3), dtype=float32, numpy=</span><span class="hljs-comment">#array([[[-6.40726149e-01, -1.64043710e-01, -4.14758682e-01],</span><span class="hljs-comment">#        [ 8.83031189e-01, -2.15735650e+00,  7.45904207e-01],...,</span><span class="hljs-comment">#        [ 1.77812195e+00, -4.44908082e-01,  1.71278393e+00],</span><span class="hljs-comment">#        [-9.77649391e-02, -2.56478786e-02,  1.69697809e+00]],...,</span><span class="hljs-comment">#       [[-1.24988317e+00, -4.40455347e-01, -9.40938056e-01],</span><span class="hljs-comment">#        [-3.51193339e-01, -1.69094354e-01, -1.55378059e-01],...,</span><span class="hljs-comment">#        [ 7.84459472e-01, -1.39909377e-02, -5.95526159e-01],</span><span class="hljs-comment">#        [-9.41911936e-01, -1.30074513e+00, -6.23348076e-03]]],</span><span class="hljs-comment">#      dtype=float32)&gt;</span><span class="hljs-comment"># 取G 通道数据</span>x[:, :, :, <span class="hljs-number">1</span>]<span class="hljs-comment">#Out[15]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(4, 32, 32), dtype=float32, numpy=</span><span class="hljs-comment">#array([[[ 1.0090125 , -0.24564391,  0.5095773 , ...,  1.5169894 ,</span><span class="hljs-comment">#         -0.18337473, -1.5871915 ],</span><span class="hljs-comment">#        [ 0.17341255, -1.3007451 , -1.2544614 , ..., -0.16909435,</span><span class="hljs-comment">#         -1.8166164 , -0.44045535],</span><span class="hljs-comment">#        [-0.5260793 ,  0.34341118, -0.83735013, ..., -0.14702302,</span><span class="hljs-comment">#         -1.0870305 , -0.30651042],</span><span class="hljs-comment">#        ...,</span>x[..., <span class="hljs-number">1</span>]<span class="hljs-comment">#Out[16]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(4, 32, 32), dtype=float32, numpy=</span><span class="hljs-comment">#array([[[ 1.0090125 , -0.24564391,  0.5095773 , ...,  1.5169894 ,</span><span class="hljs-comment">#         -0.18337473, -1.5871915 ],</span><span class="hljs-comment">#        [ 0.17341255, -1.3007451 , -1.2544614 , ..., -0.16909435,</span><span class="hljs-comment">#         -1.8166164 , -0.44045535],</span><span class="hljs-comment">#        [-0.5260793 ,  0.34341118, -0.83735013, ..., -0.14702302,</span><span class="hljs-comment">#         -1.0870305 , -0.30651042],</span><span class="hljs-comment">#        ...,</span></code></pre><h1 id="维度变换"><a href="#维度变换" class="headerlink" title="维度变换"></a>维度变换</h1><h2 id="改变试图"><a href="#改变试图" class="headerlink" title="改变试图"></a>改变试图</h2><pre><code class="hljs python"><span class="hljs-comment"># 生成向量</span>x = tf.<span class="hljs-built_in">range</span>(<span class="hljs-number">96</span>)<span class="hljs-comment"># 改变x 的视图，获得4D 张量，存储并未改变</span>tf.reshape(x, [<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>])<span class="hljs-comment">#Out[5]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(2, 4, 4, 3), dtype=int32, numpy=</span><span class="hljs-comment">#array([[[[ 0,  1,  2],</span><span class="hljs-comment">#         [ 3,  4,  5],</span><span class="hljs-comment">#         [ 6,  7,  8],</span><span class="hljs-comment">#         [ 9, 10, 11]],</span><span class="hljs-comment">#         ...,</span><span class="hljs-comment">#        [[84, 85, 86],</span><span class="hljs-comment">#         [87, 88, 89],</span><span class="hljs-comment">#         [90, 91, 92],</span><span class="hljs-comment">#         [93, 94, 95]]]])&gt;</span></code></pre><p>在 TensorFlow 中，可以通过张量的ndim 和shape 成员属性获得张量的维度数和形状：</p><pre><code class="hljs python"><span class="hljs-comment"># 获取张量的维度数和形状列表</span>x.ndim, x.shape<span class="hljs-comment">#Out[6]: (1, TensorShape([96]))</span></code></pre><p>通过 tf.reshape(x, new_shape)，可以将张量的视图任意地合法改变，例如：</p><pre><code class="hljs python">tf.reshape(x, [<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>])<span class="hljs-comment">#Out[7]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(2, 48), dtype=int32, numpy=</span><span class="hljs-comment">#array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,</span><span class="hljs-comment">#        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,</span><span class="hljs-comment">#        32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47],</span><span class="hljs-comment">#       [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,</span><span class="hljs-comment">#        64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,</span><span class="hljs-comment">#        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95]])&gt;</span></code></pre><p>其中的参数−1表示当前轴上长度需要根据张量总元素不变的法则自动推导，从而方便用户书写<br>$$<br>\frac{2<em>4</em>4*3}{2}=48<br>$$</p><p>再次改变数据的视图为[2,16,3] ，实现如下：</p><pre><code class="hljs python">tf.reshape(x, [<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">3</span>])<span class="hljs-comment">#Out[8]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(2, 16, 3), dtype=int32, numpy=</span><span class="hljs-comment">#array([[[ 0,  1,  2],...,</span><span class="hljs-comment">#        [45, 46, 47]],...,</span></code></pre><h2 id="增、删维度"><a href="#增、删维度" class="headerlink" title="增、删维度"></a>增、删维度</h2><h3 id="增加维度"><a href="#增加维度" class="headerlink" title="增加维度"></a>增加维度</h3><p>考虑一个具体例子，一张28 × 28大小的灰度图片的数据保存为shape 为[28,28]的张量，在末尾给张量增加一新维度，定义为通道数维度，此时张量的shape 变为[28,28,1]，实现如下：</p><pre><code class="hljs python"><span class="hljs-comment"># 产生矩阵</span>x = tf.random.uniform([<span class="hljs-number">28</span>, <span class="hljs-number">28</span>], maxval=<span class="hljs-number">10</span>, dtype=tf.int32)print(x)<span class="hljs-comment">#tf.Tensor(</span><span class="hljs-comment">#[[4 6 9 7 5 8 5 8 5 6 1 6 3 1 6 1 2 9 2 0 0 2 1 7 1 3 1 7]...</span><span class="hljs-comment"># [4 1 6 5 8 1 8 0 5 9 4 5 6 5 4 0 8 1 0 8 1 1 5 8 7 1 7 9]], shape=(28, 28), dtype=int32)</span><span class="hljs-comment"># 通过tf.expand_dims(x, axis)可在指定的axis 轴前可以插入一个新的维度：</span><span class="hljs-comment"># axis=2 表示宽维度后面的一个维度</span>x = tf.expand_dims(x, axis=<span class="hljs-number">2</span>)print(x)<span class="hljs-comment">#tf.Tensor(</span><span class="hljs-comment">#[[[4]...</span><span class="hljs-comment">#  [9]]], shape=(28, 28, 1), dtype=int32)</span><span class="hljs-comment"># 高维度之前插入新维度</span>x = tf.expand_dims(x, axis=<span class="hljs-number">0</span>)print(x)<span class="hljs-comment">#tf.Tensor(</span><span class="hljs-comment">#[[[[4]...</span><span class="hljs-comment">#   [9]]]], shape=(1, 28, 28, 1), dtype=int32)</span></code></pre><h3 id="删除维度"><a href="#删除维度" class="headerlink" title="删除维度"></a>删除维度</h3><p>通过tf.squeeze(x, axis)函数，axis 参数为待删除的维度的索引号</p><pre><code class="hljs python"><span class="hljs-comment"># 删除图片数量维度</span>x = tf.squeeze(x, axis=<span class="hljs-number">0</span>)print(x)<span class="hljs-comment">#tf.Tensor(</span><span class="hljs-comment">#[[[4]...</span><span class="hljs-comment">#  [9]]], shape=(28, 28, 1), dtype=int32)</span><span class="hljs-comment"># 删除图片通道数维度</span>x = tf.squeeze(x, axis=<span class="hljs-number">2</span>)print(x)<span class="hljs-comment">#tf.Tensor(</span><span class="hljs-comment">#[[4 6 9 7 5 8 5 8 5 6 1 6 3 1 6 1 2 9 2 0 0 2 1 7 1 3 1 7]...</span><span class="hljs-comment"># [4 1 6 5 8 1 8 0 5 9 4 5 6 5 4 0 8 1 0 8 1 1 5 8 7 1 7 9]], shape=(28, 28), dtype=int32)</span></code></pre><p>如果不指定维度参数 axis，即tf.squeeze(x)，那么它会默认删除所有长度为1的维度。</p><pre><code class="hljs python">x = tf.random.uniform([<span class="hljs-number">1</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>, <span class="hljs-number">1</span>], maxval=<span class="hljs-number">10</span>, dtype=tf.int32)<span class="hljs-comment"># 删除所有长度为1的维度</span>tf.squeeze(x)<span class="hljs-comment">#Out[15]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(28, 28), dtype=int32, numpy=</span><span class="hljs-comment">#array([[0, 8, 3, 2, 3, 3, 0, 5, 0, 1, 4, 7, 6, 7, 2, 3, 2, 6, 5, 1, 5, 6,</span><span class="hljs-comment">#        5, 1, 3, 1, 9, 0],</span></code></pre><h3 id="交换维度"><a href="#交换维度" class="headerlink" title="交换维度"></a>交换维度</h3><pre><code class="hljs python">x = tf.random.normal([<span class="hljs-number">2</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">3</span>])<span class="hljs-comment"># 交换维度</span>tf.transpose(x, perm=[<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<span class="hljs-comment">#Out[16]: </span><span class="hljs-comment">#&lt;tf.Tensor: shape=(2, 3, 32, 32), dtype=float32, numpy=</span><span class="hljs-comment">#array([[[[-7.99596786e-01, -5.61527647e-02, -9.59246576e-01, ...,</span></code></pre><h3 id="复制数据"><a href="#复制数据" class="headerlink" title="复制数据"></a>复制数据</h3><pre><code class="hljs python"><span class="hljs-comment"># 创建向量b</span>b = tf.constant([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<span class="hljs-comment"># 插入新维度，变成矩阵</span>b = tf.expand_dims(b, axis=<span class="hljs-number">0</span>)print(b)<span class="hljs-comment">#tf.Tensor([[1 2]], shape=(1, 2), dtype=int32)</span><span class="hljs-comment"># 样本维度上复制一份</span>b = tf.tile(b, multiples=[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>])print(b)<span class="hljs-comment">#tf.Tensor(</span><span class="hljs-comment">#[[1 2 1 2 1 2]</span><span class="hljs-comment"># [1 2 1 2 1 2]], shape=(2, 6), dtype=int32)</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>TensorFlow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tensorflow</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django_rest_framework_jwt</title>
    <link href="/2020/03/10/Django/2020-3-10-Django_rest_framework_jwt/"/>
    <url>/2020/03/10/Django/2020-3-10-Django_rest_framework_jwt/</url>
    
    <content type="html"><![CDATA[<h1 id="自定义验证错误返回"><a href="#自定义验证错误返回" class="headerlink" title="自定义验证错误返回"></a>自定义验证错误返回</h1><p>在使用Django做前端后端项目时，登陆认证方法往往使用的是jwt_token，但是想自定义登陆成功和失败的返回体。<br>打开 <code>rest_framework_jwt/settings.py</code>添加</p><pre><code class="hljs r">DEFAULTS = &#123;    <span class="hljs-keyword">...</span>    <span class="hljs-string">&#x27;JWT_RESPONSE_PAYLOAD_HANDLER&#x27;</span>:    <span class="hljs-string">&#x27;rest_framework_jwt.utils.jwt_response_payload_handler&#x27;</span>,    <span class="hljs-string">&#x27;JWT_RESPONSE_PAYLOAD_ERROR_HANDLER&#x27;</span>:    <span class="hljs-string">&#x27;rest_framework_jwt.utils.jwt_response_payload_error_handler&#x27;</span>,    <span class="hljs-keyword">...</span>&#125;<span class="hljs-comment"># List of settings that may be in string import notation.</span>IMPORT_STRINGS = (    <span class="hljs-keyword">...</span>    <span class="hljs-string">&#x27;JWT_RESPONSE_PAYLOAD_HANDLER&#x27;</span>,    <span class="hljs-string">&#x27;JWT_RESPONSE_PAYLOAD_ERROR_HANDLER&#x27;</span>,    <span class="hljs-string">&#x27;JWT_GET_USER_SECRET_KEY&#x27;</span>,)</code></pre><p>在 <code>rest_framework_jwt/utils.py</code>末尾添加</p><pre><code class="hljs python">...<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">jwt_response_payload_error_handler</span>(<span class="hljs-params">serializer, request=None</span>):</span>    <span class="hljs-keyword">return</span> &#123;        <span class="hljs-string">&quot;msg&quot;</span>: <span class="hljs-string">&quot;username or password is error.&quot;</span>,        <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-number">400</span>,        <span class="hljs-string">&quot;detail&quot;</span>: serializer.errors    &#125;</code></pre><p>在<code>rest_framework_jwt/views.py</code>修改</p><pre><code class="hljs python">jwt_response_payload_handler = api_settings.JWT_RESPONSE_PAYLOAD_HANDLERjwt_response_payload_error_handler = api_settings.JWT_RESPONSE_PAYLOAD_ERROR_HANDLER<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JSONWebTokenAPIView</span>(<span class="hljs-params">APIView</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    Base API View that various JWT interactions inherit from.</span><span class="hljs-string">    &quot;&quot;&quot;</span>    ...    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):</span>        ...        <span class="hljs-comment"># return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)</span>        error_data = jwt_response_payload_error_handler(serializer, request)        <span class="hljs-keyword">return</span> Response(error_data, status=status.HTTP_200_OK)</code></pre>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python3</tag>
      
      <tag>Django2.2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql 数据库常用命令</title>
    <link href="/2020/01/30/DataBase/2020-1-30-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/"/>
    <url>/2020/01/30/DataBase/2020-1-30-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><p><code>mysql -u root -p</code></p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p><code> CREATE DATABASE &lt;数据库名&gt;;</code></p><p><code>create database &lt;数据库名&gt; default character set utf8mb4 collate utf8mb4_unicode_ci;</code></p><h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><p><code>USE &lt;数据库名&gt;;</code></p><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p><code>drop database &lt;数据库名&gt;;</code></p><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><p><code>CREATE USER &#39;&lt;用户名&gt;&#39;@&#39;host&#39; IDENTIFIED BY &#39;&lt;密码&gt;&#39;;</code><br>host：指定该用户在哪个主机上可以登陆，如果是本地用户可用 localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符%</p><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><p><code>Delete FROM user Where User=&#39;&lt;用户名&gt;&#39; and Host=&#39;localhost&#39;;</code></p><h3 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h3><p><code>GRANT privileges ON &lt;数据库名&gt;.&lt;表名&gt; TO &#39;username&#39;@&#39;host&#39;</code></p><p>privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL</p><p>如果要授予该用户对所有数据库和表的相应操作权限则可用<code>*</code>表示，如<code>*.*</code></p><p>授权test用户拥有testDB数据库的所有权限（某个数据库的所有权限）：</p><p><code>grant all privileges on testDB.* to &#39;test&#39;@&#39;localhost&#39; identified by &#39;1234&#39;;</code></p><p><code>mysql&gt;flush privileges;</code></p><h1 id="mysql5-7-解决不用密码也能登录"><a href="#mysql5-7-解决不用密码也能登录" class="headerlink" title="mysql5.7 解决不用密码也能登录"></a>mysql5.7 解决不用密码也能登录</h1><pre><code class="hljs routeros">use mysql;update<span class="hljs-built_in"> user </span><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">authentication_string</span>=PASSWORD(&quot;密码&quot;) where <span class="hljs-attribute">user</span>=<span class="hljs-string">&#x27;root&#x27;</span>;update<span class="hljs-built_in"> user </span><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">plugin</span>=<span class="hljs-string">&quot;mysql_native_password&quot;</span>;flush privileges;quit;</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django 项目部署</title>
    <link href="/2020/01/30/Django/2020-1-30-Django%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    <url>/2020/01/30/Django/2020-1-30-Django%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h2><p><code>sudo apt-get install nginx</code></p><h2 id="安装-mysql-数据库"><a href="#安装-mysql-数据库" class="headerlink" title="安装 mysql 数据库"></a>安装 mysql 数据库</h2><h2 id="配置虚拟环境"><a href="#配置虚拟环境" class="headerlink" title="配置虚拟环境"></a>配置虚拟环境</h2><p><code>virtualenv venv</code></p><h2 id="激活虚拟环境"><a href="#激活虚拟环境" class="headerlink" title="激活虚拟环境"></a>激活虚拟环境</h2><p><code>source venv/bin/activate</code></p><h2 id="安装-uwsgi"><a href="#安装-uwsgi" class="headerlink" title="安装 uwsgi"></a>安装 uwsgi</h2><p><code>pip install uwsgi</code></p><p><code>sudo apt-get install mysql-server</code></p><h2 id="生成-requirements-txt"><a href="#生成-requirements-txt" class="headerlink" title="生成 requirements.txt"></a>生成 requirements.txt</h2><p><code>pip freeze &gt; requirements.txt</code></p><h2 id="安装-requirements-txt"><a href="#安装-requirements-txt" class="headerlink" title="安装 requirements.txt"></a>安装 requirements.txt</h2><p><code>pip install -r requirements.txt</code></p><h2 id="配置-nginx-conf"><a href="#配置-nginx-conf" class="headerlink" title="配置 nginx.conf"></a>配置 nginx.conf</h2><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">charset</span>      utf-<span class="hljs-number">8</span>;    <span class="hljs-attribute">listen</span>       <span class="hljs-number">443</span>;    <span class="hljs-attribute">server_name</span>  api.domian.com;    <span class="hljs-attribute">root</span> /var/www/api;    <span class="hljs-attribute">ssl</span> <span class="hljs-literal">on</span>;    <span class="hljs-attribute">ssl_certificate</span> /var/www/api/1_api.domian.com_bundle.crt;    <span class="hljs-attribute">ssl_certificate_key</span> /var/www/api/2_api.domian.com.key;    <span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">5m</span>;    <span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;    <span class="hljs-attribute">ssl_ciphers</span> ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;    <span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">include</span>   uwsgi_params;        <span class="hljs-attribute">uwsgi_pass</span>   <span class="hljs-number">127.0.0.1:8080</span>;    &#125;    <span class="hljs-comment"># 指向django的media目录</span>    <span class="hljs-attribute">location</span> /media  &#123;        <span class="hljs-attribute">alias</span> /var/www/api/media;     &#125;    <span class="hljs-comment"># 指向django的static目录</span>    <span class="hljs-attribute">location</span> /static &#123;        <span class="hljs-attribute">alias</span> /var/www/api/static;     &#125;&#125;<span class="hljs-section">server</span> &#123;    <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;    <span class="hljs-attribute">server_name</span> course.zguolee.cn;     <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^(.*)$</span> https://<span class="hljs-variable">$host</span><span class="hljs-variable">$1</span> <span class="hljs-literal">permanent</span>;    <span class="hljs-attribute">location</span> / &#123;        <span class="hljs-attribute">index</span> index.html index.htm;    &#125;&#125;</code></pre><h2 id="配置-uwsgi-ini"><a href="#配置-uwsgi-ini" class="headerlink" title="配置 uwsgi.ini"></a>配置 uwsgi.ini</h2><pre><code class="hljs ini"><span class="hljs-section">[uwsgi]</span><span class="hljs-comment"># variables</span><span class="hljs-attr">projectname</span> = projectname<span class="hljs-attr">projectdomain</span> = api.domian.com<span class="hljs-attr">base</span> = /var/www/api<span class="hljs-comment"># config</span><span class="hljs-attr">master</span> = <span class="hljs-literal">true</span><span class="hljs-attr">protocol</span> = uwsgi<span class="hljs-attr">env</span> = DJANGO_SETTINGS_MODULE=%(projectname).settings<span class="hljs-attr">pythonpath</span> = %(base)/%(projectname)<span class="hljs-attr">module</span> = %(projectname).wsgi<span class="hljs-attr">socket</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8080</span>   <span class="hljs-comment"># 存进程id的文件</span><span class="hljs-attr">pidfile</span>=uwsgi.pid<span class="hljs-comment"># 日志文件</span><span class="hljs-attr">daemonize</span>=uwsgi.log</code></pre><p><code>python manage.py collectstatic</code></p><p><code>service nginx start</code> 启动 <strong>nginx</strong> 转发 </p><p><code>uwsgi --ini uwsgi.ini</code></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dajngo2.2</tag>
      
      <tag>Python3.7</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
